<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>birthday to liang</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸŒŸ</text></svg>">
    <!-- Uniconså›¾æ ‡åº“ -->
    <link rel="stylesheet" href="https://unicons.iconscout.com/release/v4.0.8/css/line.css">
    <style>
        :root {
            --ui-bg: rgba(255,255,255,0.08);
            --ui-bg-strong: rgba(255,255,255,0.12);
            --ui-border: rgba(255,255,255,0.16);
            --ui-border-soft: rgba(255,255,255,0.10);
            --ui-text: #fff;
            --ui-subtext: #bbb;
            --ui-accent1: #667eea;
            --ui-accent2: #764ba2;
            --ui-shadow: 0 10px 30px rgba(0,0,0,0.35);
            --ui-glow: 0 0 0 1px rgba(255,255,255,0.06), 0 8px 30px rgba(102,126,234,0.18);
            --radius: 12px;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
                /* æŸ”å’Œçš„èƒŒæ™¯æ˜Ÿäº‘æ¸å˜ */
                background-image:
                    radial-gradient(1200px 600px at 10% 10%, rgba(102,126,234,0.08), rgba(0,0,0,0)),
                    radial-gradient(900px 500px at 80% 30%, rgba(118,75,162,0.06), rgba(0,0,0,0)),
                    radial-gradient(800px 800px at 50% 90%, rgba(0,183,255,0.05), rgba(0,0,0,0));
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }
        
        #canvas-container canvas {
            display: block;
            outline: none;
            border: none;
                filter: drop-shadow(0 0 0 rgba(0,0,0,0)); /* é˜²æ­¢æµè§ˆå™¨é»˜è®¤é˜´å½± */
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
                background: rgba(0, 0, 0, 0.55);
                padding: 16px 20px;
                border-radius: var(--radius);
            z-index: 100;
            backdrop-filter: blur(10px);
                border: 1px solid var(--ui-border-soft);
                box-shadow: var(--ui-shadow);
        }

        #info h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #fff;
        }

        #info p {
            margin: 5px 0;
            font-size: 14px;
                color: var(--ui-subtext);
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
                background: rgba(0, 0, 0, 0.55);
                padding: 16px 20px;
                border-radius: var(--radius);
            z-index: 100;
            backdrop-filter: blur(10px);
                border: 1px solid var(--ui-border-soft);
                box-shadow: var(--ui-shadow);
        }

        #camera-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
                background: rgba(0, 0, 0, 0.55);
                padding: 16px 20px;
                border-radius: var(--radius);
            z-index: 100;
            backdrop-filter: blur(10px);
                border: 1px solid var(--ui-border-soft);
                box-shadow: var(--ui-shadow);
        }

        #controls label,
        #camera-controls label {
            display: block;
            margin: 8px 0;
            font-size: 14px;
                color: var(--ui-subtext);
        }

        #controls input[type="range"],
        #camera-controls input[type="range"] {
            width: 300px;
            margin-left: 10px;
                accent-color: #8aa0ff;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
                padding: 24px 28px;
                background: rgba(0,0,0,0.55);
                border: 1px solid var(--ui-border-soft);
                border-radius: var(--radius);
                backdrop-filter: blur(10px);
                box-shadow: var(--ui-shadow);
        }

        #loading h2 {
            font-size: 28px;
            margin-bottom: 20px;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #upload-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
                background: rgba(10, 12, 20, 0.75);
                padding: 36px 40px;
                border-radius: var(--radius);
            backdrop-filter: blur(10px);
                border: 1px solid var(--ui-border);
            min-width: 400px;
                box-shadow: var(--ui-glow);
        }

        #upload-panel h2 {
            font-size: 28px;
            margin-bottom: 15px;
            color: #fff;
        }

        #upload-panel p {
            font-size: 14px;
                color: var(--ui-subtext);
            margin-bottom: 25px;
        }

        #file-input-wrapper {
            position: relative;
            display: inline-block;
            margin-bottom: 20px;
        }

        #file-input {
            display: none;
        }

        .file-input-button {
            display: inline-block;
            padding: 12px 30px;
                background: linear-gradient(135deg, rgba(102,126,234,0.95) 0%, rgba(118,75,162,0.95) 100%);
                color: var(--ui-text);
            border: none;
                border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
                box-shadow: var(--ui-glow);
        }

        .file-input-button:hover {
            transform: translateY(-2px);
                box-shadow: 0 10px 25px rgba(102, 126, 234, 0.35);
        }

        .file-input-button:active {
            transform: translateY(0);
        }

        #file-name {
            display: block;
            margin-top: 15px;
            font-size: 14px;
                color: #aab2ff;
            word-break: break-all;
        }

        #upload-error {
                color: #ff8f8f;
            font-size: 14px;
            margin-top: 15px;
            display: none;
        }

        #stats {
            position: absolute;
                bottom: 38px; /* å¯¹é½å³ä¸‹è§’åœ†å½¢æŒ‰é’®åœ†å¿ƒï¼ˆ20 + 18ï¼‰ */
                right: 38px;  /* å¯¹é½å³ä¸‹è§’åœ†å½¢æŒ‰é’®åœ†å¿ƒï¼ˆ20 + 18ï¼‰ */
                background: rgba(0, 0, 0, 0.55);
                padding: 16px 20px;
                border-radius: var(--radius);
            z-index: 100;
            backdrop-filter: blur(10px);
                border: 1px solid var(--ui-border-soft);
            font-size: 14px;
                box-shadow: var(--ui-shadow);
                transition: transform .2s ease, opacity .2s ease, visibility .2s ease;
                transform-origin: bottom right;
                opacity: 0;
                visibility: hidden;
                transform: scale(0.98) translateY(8px);
        }

        .stat-item {
            margin: 5px 0;
                color: var(--ui-subtext);
        }
            /* å¯æŠ˜å çŠ¶æ€ï¼ˆä»…è§†è§‰éšè—ï¼‰ */
            #stats.collapsed {
                opacity: 0;
                visibility: hidden;
                transform: translateY(8px) scale(0.98);
            }

        #star-list-panel {
            position: absolute;
                right: 38px;  /* å¯¹é½å³ä¸‹è§’åœ†å½¢æŒ‰é’®åœ†å¿ƒï¼ˆ20 + 18ï¼‰ */
                bottom: 38px; /* å¯¹é½å³ä¸‹è§’åœ†å½¢æŒ‰é’®åœ†å¿ƒï¼ˆ20 + 18ï¼‰ */
            width: 350px;
            max-height: calc(80vh - 120px);
                background: rgba(8, 10, 18, 0.75);
                padding: 14px 14px 10px;
                border-radius: var(--radius);
            z-index: 100;
            backdrop-filter: blur(10px);
                border: 1px solid var(--ui-border);
            display: none;
            flex-direction: column;
                box-shadow: var(--ui-glow);
                transition: transform .2s ease, opacity .2s ease, visibility .2s ease;
                transform-origin: bottom right;
                opacity: 0;
                visibility: hidden;
                transform: scale(0.98) translateY(8px);
        }
            /* å¯æŠ˜å çŠ¶æ€ï¼ˆä»…è§†è§‰éšè—ï¼‰ */
            #star-list-panel.collapsed {
                opacity: 0;
                visibility: hidden;
                transform: scale(0.98) translateY(8px);
            }
            /* é¢æ¿å¯è§çŠ¶æ€ï¼ˆç”¨äºå±•å¼€åŠ¨ç”»ï¼‰ */
            #stats.visible,
            #star-list-panel.visible,
            #auto-tour-panel.visible {
                opacity: 1;
                visibility: visible;
                transform: scale(1) translateY(0);
            }
            /* è‡ªåŠ¨æ¼«æ¸¸é¢æ¿æ ·å¼ */
            #auto-tour-panel {
                position: absolute;
                right: 38px;  /* å¯¹é½å³ä¸‹è§’åœ†å½¢æŒ‰é’®åœ†å¿ƒï¼ˆ20 + 18ï¼‰ */
                bottom: 38px; /* å¯¹é½å³ä¸‹è§’åœ†å½¢æŒ‰é’®åœ†å¿ƒï¼ˆ20 + 18ï¼‰ */
                width: 280px;
                max-height: calc(80vh - 120px);
                background: rgba(8, 10, 18, 0.75);
                padding: 14px 14px 10px;
                border-radius: var(--radius);
                z-index: 100;
                backdrop-filter: blur(10px);
                border: 1px solid var(--ui-border);
                display: none;
                flex-direction: column;
                box-shadow: var(--ui-glow);
                transition: transform .2s ease, opacity .2s ease, visibility .2s ease;
                transform-origin: bottom right;
                opacity: 0;
                visibility: hidden;
                transform: scale(0.98) translateY(8px);
            }

        #star-list-panel h2 {
                font-size: 16px;
                margin: 2px 4px 10px;
                color: #f0f3ff;
                letter-spacing: 0.4px;
                font-weight: 700;
        }

        #star-search {
            width: 100%;
            padding: 8px;
                margin: 0 0 10px;
                background: rgba(255, 255, 255, 0.08);
                border: 1px solid rgba(255, 255, 255, 0.18);
                border-radius: 8px;
            color: #fff;
            font-size: 14px;
            box-sizing: border-box;
                outline: none;
                transition: box-shadow .2s ease, border-color .2s ease;
            }
            #star-search:focus {
                border-color: rgba(138, 160, 255, 0.6);
                box-shadow: 0 0 0 3px rgba(138, 160, 255, 0.25);
        }

        #star-search::placeholder {
            color: #aaa;
        }

        #star-list-container {
            overflow-y: auto;
            max-height: calc(80vh - 100px);
            flex: 1;
                padding-right: 6px;
            }
            /* ä¼˜åŒ–æ»šåŠ¨æ¡ */
            #star-list-container::-webkit-scrollbar {
                width: 8px;
            }
            #star-list-container::-webkit-scrollbar-track {
                background: rgba(255,255,255,0.06);
                border-radius: 8px;
            }
            #star-list-container::-webkit-scrollbar-thumb {
                background: linear-gradient(180deg, rgba(138,160,255,0.6), rgba(118,75,162,0.6));
                border-radius: 8px;
            }
            #star-list-container::-webkit-scrollbar-thumb:hover {
                background: linear-gradient(180deg, rgba(138,160,255,0.85), rgba(118,75,162,0.85));
        }

        #star-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #star-list li {
                padding: 8px 10px;
                margin: 4px 0;
                background: rgba(255, 255, 255, 0.06);
                border-radius: 8px;
                color: #d5d9ff;
                font-size: 13.5px;
            cursor: pointer;
                transition: background 0.2s, transform .12s ease, box-shadow .2s ease;
                border: 1px solid rgba(255,255,255,0.10);
        }

        #star-list li:hover {
                background: rgba(255, 255, 255, 0.12);
                transform: translateY(-1px);
                box-shadow: 0 6px 18px rgba(0,0,0,0.25);
        }

        #star-list li.highlight {
                background: linear-gradient(135deg, rgba(102,126,234,0.32), rgba(118,75,162,0.30));
                border-color: rgba(138, 160, 255, 0.5);
                color: #fff;
        }

        #star-list-count {
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
            text-align: center;
        }

        #nearest-star-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
                background: rgba(0, 0, 0, 0.55);
                padding: 14px 16px;
                border-radius: var(--radius);
            z-index: 100;
            backdrop-filter: blur(10px);
                border: 1px solid var(--ui-border-soft);
            font-size: 14px;
            display: none;
                box-shadow: var(--ui-shadow);
        }
            /* å¼ºåˆ¶éšè—æœ€è¿‘æ’æ˜Ÿä¿¡æ¯ */
            #nearest-star-info { display: none !important; }
            /* éšè—æœ€è¿‘æ’æ˜Ÿä¿¡æ¯ï¼ˆéœ€æ±‚ï¼‰ */
            #nearest-star-info { display: none !important; }

        #nearest-star-info .label {
            color: #aaa;
            margin-right: 8px;
        }

        #nearest-star-info .value {
            color: #fff;
            font-weight: bold;
        }
        
        /* é¡¶éƒ¨å·¥å…·æ  */
        #topbar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 56px;
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
                background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0));
            z-index: 300;
            pointer-events: none;
                border-bottom: 1px solid rgba(255,255,255,0.08);
                box-shadow: 0 10px 24px rgba(0,0,0,0.25);
        }
        #topbar .brand {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            color: #fff;
            letter-spacing: 0.5px;
            pointer-events: auto;
        }
        #topbar .brand .title {
                font-size: 15px;
                opacity: 0.95;
                text-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }
        #topbar .actions {
            display: flex;
            gap: 8px;
            pointer-events: auto;
        }
        .ui-btn {
            height: 32px;
            padding: 0 12px;
                border-radius: 10px;
                border: 1px solid rgba(255,255,255,0.14);
                background: rgba(255,255,255,0.10);
            color: #fff;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
                backdrop-filter: blur(8px);
                box-shadow: 0 6px 20px rgba(0,0,0,0.25);
        }
        .ui-btn:hover {
                background: rgba(255,255,255,0.16);
                transform: translateY(-1px);
                box-shadow: 0 10px 28px rgba(0,0,0,0.28);
        }
        .ui-btn:active {
            transform: translateY(0);
        }
        .ui-btn.primary {
                background: linear-gradient(135deg, rgba(102,126,234,0.95), rgba(118,75,162,0.95));
                border-color: rgba(255,255,255,0.2);
                box-shadow: var(--ui-glow);
                animation: btnPulse 3s ease-in-out infinite;
            }
            @keyframes btnPulse {
                0%, 100% { box-shadow: var(--ui-glow); }
                50% { box-shadow: 0 0 0 1px rgba(255,255,255,0.06), 0 14px 36px rgba(102,126,234,0.28); }
            }
            .ui-btn:focus-visible {
                outline: none;
                box-shadow: 0 0 0 3px rgba(138,160,255,0.35);
        }
        
        /* å¸®åŠ©å¼¹çª— */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.55);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 400;
        }
        .modal {
                background: rgba(10,12,18,0.78);
                border: 1px solid rgba(255,255,255,0.15);
                border-radius: var(--radius);
                padding: 18px 20px;
            width: min(520px, 92vw);
                color: #e7e9ff;
            backdrop-filter: blur(12px);
                box-shadow: 0 18px 40px rgba(0,0,0,0.45);
                animation: modalIn .2s ease;
        }
        .modal h3 {
            font-size: 18px;
            color: #fff;
            margin-bottom: 10px;
        }
        .modal p, .modal li {
            font-size: 13px;
                color: var(--ui-subtext);
            line-height: 1.7;
        }
        .modal .modal-actions {
            margin-top: 12px;
            text-align: right;
        }
            @keyframes modalIn {
                from { transform: translateY(6px); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }
        
        /* ä¸Šä¼ é¢æ¿æ‹–æ‹½æ€ */
        #upload-panel.dragover {
            border-color: rgba(102,126,234,0.6);
            box-shadow: 0 0 0 3px rgba(102,126,234,0.25);
        }
            /* é¡¶éƒ¨ï¼šéšè—é«˜ç²¾åº¦åˆ‡æ¢æŒ‰é’® */
            #btn-toggle-precision { display: none !important; }

            /* åœ°çƒå›¾æ ‡æ ·å¼ */
            #earth-globe-icon {
                position: fixed;
                right: 20px;
                bottom: 20px;
                z-index: 340;
                width: 0;
                height: 0;
                /* åœ†å¿ƒå¤§å¹…å¾€å·¦ä¸Šç§»åŠ¨ï¼Œä¸æŒ‰é’®å®¹å™¨ä¿æŒä¸€è‡´ */
                transform: translate(-60px, -60px);
                /* ä½¿ç”¨transform-originç¡®ä¿ç¼©æ”¾æ—¶ä»¥åœ†å¿ƒä¸ºä¸­å¿ƒ */
                transform-origin: center center;
            }
            #earth-globe-icon i {
                display: block;
                transition: transform 0.3s ease, filter 0.3s ease;
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
            }
            #earth-globe-icon:hover i {
                filter: drop-shadow(0 0 15px rgba(74, 144, 226, 0.8));
            }
            
            /* å³ä¸‹è§’é¢æ¿åˆ‡æ¢æŒ‰é’®å®¹å™¨ï¼ˆå‚ç›´æ’åˆ—ï¼‰ */
            #corner-buttons {
                position: fixed;
                right: 20px;
                bottom: 20px;
                z-index: 350;
                width: 0;
                height: 0;
                /* åœ†å¿ƒå¤§å¹…å¾€å·¦ä¸Šç§»åŠ¨ */
                transform: translate(-60px, -60px);
            }
            .corner-switch {
                width: 36px;
                height: 36px;
                border-radius: 50%;
                border: 1px solid rgba(255,255,255,0.16);
                background: rgba(255,255,255,0.10);
                color: #fff;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                backdrop-filter: blur(8px);
                box-shadow: 0 8px 24px rgba(0,0,0,0.35);
                transition: background .2s ease, box-shadow .2s ease;
                position: absolute;
                right: 0;
                bottom: 0;
            }
            .corner-switch:hover {
                background: rgba(255,255,255,0.16);
                box-shadow: 0 12px 28px rgba(0,0,0,0.38);
            }
            .corner-switch.active {
                border-color: rgba(138,160,255,0.6);
                box-shadow: 0 0 0 1px rgba(255,255,255,0.06), 0 12px 28px rgba(102,126,234,0.28);
                background: rgba(255,255,255,0.16);
            }
            #btn-show-stats { transform: translate(0, -88px); }
            #btn-show-auto-tour { transform: translate(-62px, -62px); }
            #btn-show-list { transform: translate(-88px, 0); }
        
        @media (max-width: 920px) {
            #star-list-panel {
                    right: 12px;
                width: calc(100vw - 24px);
                    bottom: 12px;
                    max-height: calc(55vh);
            }
            #stats {
                    right: 12px;
                    bottom: 12px;
            }
            #info {
                left: 12px;
            }
                .ui-btn { height: 34px; }
                #upload-panel { width: calc(100vw - 32px); min-width: 0; }
                #corner-buttons { right: 12px; bottom: 12px; }
            #stats { right: 30px; bottom: 30px; }
            #star-list-panel { right: 30px; bottom: 30px; }
        }
    </style>
</head>
<body>
    <div id="topbar">
        <div class="brand">
            <div class="title">birthday to liang</div>
        </div>
        <div class="actions">
            <button id="btn-help" class="ui-btn">å¸®åŠ©</button>
            <button id="btn-toggle-precision" class="ui-btn">é«˜ç²¾åº¦: å…³</button>
        </div>
    </div>
    <div id="help-backdrop" class="modal-backdrop">
        <div class="modal">
            <h3>ä½¿ç”¨è¯´æ˜</h3>
            <ul style="margin-left: 18px;">
                <li>é¼ æ ‡å·¦é”®+ç§»åŠ¨ï¼šç¯è§†ï¼›W/A/S/D/Q/Eï¼šå‰/å·¦/å/å³/ä¸Š/ä¸‹</li>
                <li>ç‚¹å‡»æ’æ˜Ÿç¼–å·ï¼šé£å‘è¯¥æ’æ˜Ÿå¹¶ç¯ç»•</li>
                <li>ä¸Šä¼ JSONæ˜Ÿè¡¨ï¼Œæ”¯æŒå¯¹è±¡æ•°ç»„æˆ–äºŒç»´æ•°ç»„ï¼Œå¹¶å¯åŒ…å«é¢„å¤„ç†å…«å‰æ ‘</li>
            </ul>
            <div class="modal-actions">
                <button id="btn-close-help" class="ui-btn primary">æˆ‘çŸ¥é“äº†</button>
            </div>
        </div>
    </div>
    <div id="canvas-container"></div>
    
    <div id="loading" style="display: none;">
        <h2>ğŸŒŸ åŠ è½½æ’æ˜Ÿæ•°æ®ä¸­...</h2>
        <div class="spinner"></div>
        <p id="loading-text">æ­£åœ¨å¤„ç†æ•°æ®</p>
    </div>

    <div id="upload-panel">
        <h2>birthday to liang</h2>
        <p>è¯·ä¸Šä¼ æ˜Ÿè¡¨æ•°æ®æ–‡ä»¶ (JSONæ ¼å¼)</p>
        <div id="file-input-wrapper">
            <input type="file" id="file-input" accept=".json,application/json">
            <label for="file-input" class="file-input-button">
                ğŸ“ é€‰æ‹©æ–‡ä»¶
            </label>
        </div>
        <div id="file-name"></div>
        <div id="upload-error"></div>
    </div>

    <div id="info" style="display: none;">
        <h1>birthday to liang</h1>
        <p>æ•°æ®æ¥æº: Gaia DR3</p>
        <p>åæ ‡ç³»: é“¶æ²³åæ ‡ç³»ï¼ˆä»¥å¤ªé˜³ä¸ºä¸­å¿ƒï¼‰</p>
        <p id="star-count">æ’æ˜Ÿæ•°é‡: åŠ è½½ä¸­...</p>
    </div>

    <div id="stats" style="display: none;">
        <div class="stat-item">FPS: <span id="fps">60</span></div>
        <div class="stat-item" style="margin-top: 8px;">
            é€Ÿåº¦é¢„è®¾:
            <button id="speed-high" style="margin-left: 8px; padding: 2px 6px; cursor: pointer;">é«˜é€Ÿ</button>
            <button id="speed-medium" style="margin-left: 6px; padding: 2px 6px; cursor: pointer;">ä¸­é€Ÿ</button>
            <button id="speed-low" style="margin-left: 6px; padding: 2px 6px; cursor: pointer;">ä½é€Ÿ</button>
        </div>
    </div>

    <div id="nearest-star-info">
        <div>
            <span class="label">æœ€è¿‘æ’æ˜Ÿè·ç¦»:</span>
            <span class="value" id="nearest-star-distance">--</span>
            <span class="label" style="margin-left: 10px;">æ’æ˜Ÿç¼–å·:</span>
            <span class="value" id="nearest-star-id">--</span>
        </div>
    </div>

    <div id="star-list-panel">
        <h2>ğŸŒŸ æ’æ˜Ÿç¼–å·åˆ—è¡¨</h2>
        <input type="text" id="star-search" placeholder="æœç´¢æ’æ˜Ÿç¼–å·...">
        <div id="star-list-container">
            <ul id="star-list"></ul>
        </div>
        <div id="star-list-count">å…± 0 é¢—æ’æ˜Ÿ</div>
        <button id="btn-jump-to-last-auto-tour" class="ui-btn" style="margin-top: 8px; width: 100%;">è·³è½¬åˆ°ä¸Šä¸€æ¬¡è‡ªåŠ¨æ¼«æ¸¸æ˜Ÿ</button>
    </div>
    <!-- è‡ªåŠ¨æ¼«æ¸¸é¢æ¿ -->
    <div id="auto-tour-panel" class="ui-panel">
        <h3 style="margin: 0 0 12px 0; font-size: 16px;">ğŸ¬ è‡ªåŠ¨æ¼«æ¸¸</h3>
        <div style="display: flex; flex-direction: column; gap: 8px;">
            <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                <button id="btn-auto-tour-start" class="ui-btn primary" style="flex: 1; min-width: 80px;">å¼€å§‹</button>
                <button id="btn-auto-tour-pause" class="ui-btn" style="flex: 1; min-width: 80px;">æš‚åœ</button>
            </div>
            <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                <button id="btn-auto-tour-continue" class="ui-btn" style="flex: 1; min-width: 80px;">ç»§ç»­ä¸Šæ¬¡</button>
                <button id="btn-auto-tour-restart" class="ui-btn" style="flex: 1; min-width: 80px;">é‡æ–°å¼€å§‹</button>
            </div>
            <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                <button id="btn-auto-tour-random" class="ui-btn" style="flex: 1; min-width: 80px;">éšæœºé€‰æ‹©</button>
                <button id="btn-auto-tour-jump-last" class="ui-btn" style="flex: 1; min-width: 80px;">è·³è½¬ä¸Šæ¬¡</button>
            </div>
            <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                <button id="btn-auto-tour-forward" class="ui-btn" style="flex: 1; min-width: 80px;">é¡ºåºæ¼«æ¸¸</button>
                <button id="btn-auto-tour-backward" class="ui-btn" style="flex: 1; min-width: 80px;">å€’åºæ¼«æ¸¸</button>
            </div>
            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 12px; color: #aaa;">
                <div>å½“å‰: <span id="auto-tour-current">-</span> / <span id="auto-tour-total">-</span></div>
                <div>æ¨¡å¼: <span id="auto-tour-mode">-</span></div>
            </div>
        </div>
    </div>

    <!-- åœ°çƒå›¾æ ‡ï¼ˆUniconsï¼‰ -->
    <div id="earth-globe-icon" style="position: fixed; right: 20px; bottom: 20px; z-index: 340; pointer-events: auto; cursor: pointer; transform: translate(-60px, -60px); width: 0; height: 0;">
        <i class="uil uil-globe" style="font-size: 48px; color: #4a90e2; text-shadow: 0 0 20px rgba(74, 144, 226, 0.5); display: block; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);"></i>
    </div>
    
    <!-- å³ä¸‹è§’ä¸‰ä¸ªåˆ‡æ¢æŒ‰é’®ï¼šåªèƒ½æ˜¾ç¤ºä¸€ä¸ªé¢æ¿ -->
    <div id="corner-buttons">
        <button id="btn-show-stats" class="corner-switch" title="è®¾ç½®/ç»Ÿè®¡">âš™ï¸</button>
        <button id="btn-show-list" class="corner-switch" title="æ’æ˜Ÿåˆ—è¡¨">ğŸ—’ï¸</button>
        <button id="btn-show-auto-tour" class="corner-switch" title="è‡ªåŠ¨æ¼«æ¸¸">ğŸ¬</button>
    </div>
    
    

    <div id="camera-controls" style="display: none;">
        <label>
            ç›¸æœºé€Ÿåº¦: <span id="camera-speed-value">25</span>
            <input type="range" id="camera-speed-slider" min="1" max="100" value="25" step="1">
        </label>
        <label>
            é€Ÿåº¦å€æ•°1: <span id="speed-multiplier1-value">0.40</span>x (<span id="speed-multiplier1-percent">40</span>%)
            <input type="range" id="speed-multiplier1-slider" min="-2" max="2" value="-0.39794" step="0.01">
        </label>
        <label>
            é€Ÿåº¦å€æ•°2: <span id="speed-multiplier2-value">1.0</span>x (<span id="speed-multiplier2-percent">100</span>%)
            <input type="range" id="speed-multiplier2-slider" min="-2" max="2" value="0" step="0.01">
        </label>
        <label>
            é€Ÿåº¦å€æ•°3: <span id="speed-multiplier3-value">1.0</span>x (<span id="speed-multiplier3-percent">100</span>%)
            <input type="range" id="speed-multiplier3-slider" min="-2" max="2" value="0" step="0.01">
        </label>
        <label style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.2);">
            <input type="checkbox" id="high-precision-toggle" style="margin-right: 8px;">
            <span style="color: #4CAF50; font-weight: bold;">é«˜ç²¾åº¦å˜æ¢æ¨¡å¼</span>
        </label>
        <p style="font-size: 12px; color: #aaa; margin-top: 5px; margin-left: 0;">
            ä½¿ç”¨é«˜ç²¾åº¦æ—‹è½¬çŸ©é˜µå’Œæ•°å­¦è¿ç®—ï¼Œå‡å°‘ç´¯ç§¯è¯¯å·®
        </p>
    </div>

    <div id="controls" style="display: none;">
        <label>
            æ˜¾ç¤ºæ•°é‡: <span id="limit-value">100000</span>
            <input type="range" id="limit-slider" min="1000" max="1000000" value="100000" step="1000">
        </label>
        <label>
            æ’æ˜Ÿå¤§å°: <span id="size-value">1.0</span>
            <input type="range" id="size-slider" min="0.1" max="5" value="1.0" step="0.1">
        </label>
        <label>
            äº®åº¦: <span id="brightness-value">1.0</span>
            <input type="range" id="brightness-slider" min="0.1" max="3" value="1.0" step="0.1">
        </label>
        <label>
            æ—‹è½¬é€Ÿåº¦: <span id="rotation-value">0.5</span>
            <input type="range" id="rotation-slider" min="0" max="2" value="0.5" step="0.1">
        </label>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const SCALE = 1000000000;
        const SCALE_F = 1000000000.0;
        
        const HighPrecisionMath = {
            SCALE: SCALE,
            SCALE_F: SCALE_F,
            
            toInt: function(f) {
                return Math.round(f * SCALE);
            },
            
            toFloat: function(i) {
                return i / SCALE_F;
            },
            
            vec3FloatToInt: function(vec) {
                return {
                    x: Math.round(vec.x * SCALE),
                    y: Math.round(vec.y * SCALE),
                    z: Math.round(vec.z * SCALE)
                };
            },
            
            vec3IntToFloat: function(vec) {
                return {
                    x: vec.x / SCALE_F,
                    y: vec.y / SCALE_F,
                    z: vec.z / SCALE_F
                };
            },
            
            Int: {
                addVectors: function(v1, v2) {
                    return {
                        x: v1.x + v2.x,
                        y: v1.y + v2.y,
                        z: v1.z + v2.z
                    };
                },
                
                subtractVectors: function(v1, v2) {
                    return {
                        x: v1.x - v2.x,
                        y: v1.y - v2.y,
                        z: v1.z - v2.z
                    };
                },
                
                multiplyScalar: function(vec, scalarInt) {
                    return {
                        x: Math.round((vec.x * scalarInt) / SCALE),
                        y: Math.round((vec.y * scalarInt) / SCALE),
                        z: Math.round((vec.z * scalarInt) / SCALE)
                    };
                },
                
                normalizeVector: function(vec) {
                    const x = vec.x || 0;
                    const y = vec.y || 0;
                    const z = vec.z || 0;
                    const lengthSq = (x * x + y * y + z * z) / (SCALE * SCALE);
                    
                    if (lengthSq < 1e-20) {
                        return { x: 0, y: 0, z: 0 };
                    }
                    
                    const length = Math.sqrt(lengthSq);
                    const invLength = SCALE / length;
                    
                    return {
                        x: Math.round(x * invLength / SCALE),
                        y: Math.round(y * invLength / SCALE),
                        z: Math.round(z * invLength / SCALE)
                    };
                },
                
                dot: function(v1, v2) {
                    return Math.round((v1.x * v2.x + v1.y * v2.y + v1.z * v2.z) / SCALE);
                },
                
                length: function(vec) {
                    const x = vec.x || 0;
                    const y = vec.y || 0;
                    const z = vec.z || 0;
                    const lengthSq = (x * x + y * y + z * z) / (SCALE * SCALE);
                    return Math.round(Math.sqrt(lengthSq) * SCALE);
                },
                
                lengthSq: function(vec) {
                    const x = vec.x || 0;
                    const y = vec.y || 0;
                    const z = vec.z || 0;
                    return Math.round((x * x + y * y + z * z) / SCALE);
                }
            },
            
            Float: {
                addVectors: function(v1, v2) {
                    return {
                        x: v1.x + v2.x,
                        y: v1.y + v2.y,
                        z: v1.z + v2.z
                    };
                },
                
                subtractVectors: function(v1, v2) {
                    return {
                        x: v1.x - v2.x,
                        y: v1.y - v2.y,
                        z: v1.z - v2.z
                    };
                },
                
                multiplyScalar: function(vec, scalar) {
                    return {
                        x: vec.x * scalar,
                        y: vec.y * scalar,
                        z: vec.z * scalar
                    };
                },
                
                normalizeVector: function(vec) {
                    const x = vec.x || 0;
                    const y = vec.y || 0;
                    const z = vec.z || 0;
                    const lengthSq = x * x + y * y + z * z;
                    
                    if (lengthSq < 1e-20) {
                        return { x: 0, y: 0, z: 0 };
                    }
                    
                    const length = Math.sqrt(lengthSq);
                    const invLength = 1.0 / length;
                    
                    return {
                        x: x * invLength,
                        y: y * invLength,
                        z: z * invLength
                    };
                },
                
                dot: function(v1, v2) {
                    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
                },
                
                length: function(vec) {
                    const x = vec.x || 0;
                    const y = vec.y || 0;
                    const z = vec.z || 0;
                    return Math.sqrt(x * x + y * y + z * z);
                },
                
                lengthSq: function(vec) {
                    const x = vec.x || 0;
                    const y = vec.y || 0;
                    const z = vec.z || 0;
                    return x * x + y * y + z * z;
                }
            },
            
            normalizeAngle: function(angle) {
                const TWO_PI = 2 * Math.PI;
                angle = angle % TWO_PI;
                if (angle > Math.PI) {
                    angle -= TWO_PI;
                } else if (angle < -Math.PI) {
                    angle += TWO_PI;
                }
                return angle;
            },
            
            getRotationMatrix: function(yaw, pitch) {
                const normalizedYaw = this.normalizeAngle(yaw);
                const normalizedPitch = this.normalizeAngle(pitch);
                
                const cy = Math.cos(normalizedYaw);
                const sy = Math.sin(normalizedYaw);
                const cp = Math.cos(normalizedPitch);
                const sp = Math.sin(normalizedPitch);
                return {
                    m00: cy,           m01: 0,            m02: sy,
                    m10: sy * sp,      m11: cp,           m12: -cy * sp,
                    m20: -sy * cp,     m21: sp,           m22: cy * cp
                };
            },
            
            transformVector: function(vec, matrix) {
                return {
                    x: vec.x * matrix.m00 + vec.y * matrix.m01 + vec.z * matrix.m02,
                    y: vec.x * matrix.m10 + vec.y * matrix.m11 + vec.z * matrix.m12,
                    z: vec.x * matrix.m20 + vec.y * matrix.m21 + vec.z * matrix.m22
                };
            },
            
            addVectorsInt: function(v1, v2) { return this.Int.addVectors(v1, v2); },
            subtractVectorsInt: function(v1, v2) { return this.Int.subtractVectors(v1, v2); },
            multiplyScalarInt: function(vec, scalarInt) { return this.Int.multiplyScalar(vec, scalarInt); },
            normalizeVectorInt: function(vec) { return this.Int.normalizeVector(vec); },
            
            addVectors: function(v1, v2) { return this.Float.addVectors(v1, v2); },
            subtractVectors: function(v1, v2) { return this.Float.subtractVectors(v1, v2); },
            multiplyScalar: function(vec, scalar) { return this.Float.multiplyScalar(vec, scalar); },
            normalizeVector: function(vec) { return this.Float.normalizeVector(vec); }
        };

        THREE.OrbitControls = function(camera, domElement) {
            this.object = camera;
            this.domElement = domElement || document;
            this.enableDamping = true;
            this.dampingFactor = 0.1;
            // é€Ÿåº¦å­˜å‚¨ä¸ºæ•´æ•°ï¼ˆä¹˜ä»¥SCALEï¼‰
            this.moveSpeed = HighPrecisionMath.toInt(10);
            this.rotationSpeed = 0.002;
            
            // ä½¿ç”¨å››å…ƒæ•°å­˜å‚¨æ—‹è½¬ï¼Œé¿å…ä¸‡è±¡é”
            this.quaternion = new THREE.Quaternion();
            this.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), 0);
            
            // é«˜ç²¾åº¦ä½ç½®ï¼ˆæ•´æ•°åæ ‡ï¼‰
            this.positionInt = {
                x: HighPrecisionMath.toInt(camera.position.x),
                y: HighPrecisionMath.toInt(camera.position.y),
                z: HighPrecisionMath.toInt(camera.position.z)
            };
            
            this.highPrecisionMode = false;
            
            this.fixedAtGalacticCenter = false;
            
            this.positionError = new THREE.Vector3(0, 0, 0);
            this.rotationError = { yaw: 0, pitch: 0 };
            
            const keys = {
                w: false,
                a: false,
                s: false,
                d: false,
                q: false,
                e: false
            };
            
            let isPointerLocked = false;
            let mouseX = 0;
            let mouseY = 0;
            
            // ä¸´æ—¶å‘é‡ï¼Œç”¨äºè®¡ç®—
            const tempAxisX = new THREE.Vector3(1, 0, 0);
            const tempAxisY = new THREE.Vector3(0, 1, 0);
            const tempQuaternion = new THREE.Quaternion();
            
            const onMouseMove = (e) => {
                if (!isPointerLocked) return;
                
                const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
                const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
                
                if (movementX === 0 && movementY === 0) return;
                
                if (movementX !== 0) {
                    const deltaYaw = -movementX * this.rotationSpeed;
                    const yawQuat = new THREE.Quaternion();
                    yawQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaYaw);
                    this.quaternion.multiplyQuaternions(yawQuat, this.quaternion);
                }
                
                if (movementY !== 0) {
                    const deltaPitch = -movementY * this.rotationSpeed;
                    const rightAxis = new THREE.Vector3(1, 0, 0);
                    rightAxis.applyQuaternion(this.quaternion);
                    const pitchQuat = new THREE.Quaternion();
                    pitchQuat.setFromAxisAngle(rightAxis, deltaPitch);
                    this.quaternion.multiplyQuaternions(pitchQuat, this.quaternion);
                }
                
                this.quaternion.normalize();
            };
            
            const onMouseDown = () => {
                if (typeof window.cancelFollowAndOrbit === 'function') window.cancelFollowAndOrbit();
                if (!isPointerLocked) {
                    domElement.requestPointerLock = domElement.requestPointerLock || 
                                                   domElement.mozRequestPointerLock || 
                                                   domElement.webkitRequestPointerLock;
                    if (domElement.requestPointerLock) {
                        domElement.requestPointerLock();
                    }
                }
            };
            
            const onPointerLockChange = () => {
                isPointerLocked = document.pointerLockElement === domElement ||
                                 document.mozPointerLockElement === domElement ||
                                 document.webkitPointerLockElement === domElement;
            };
            
            const onKeyDown = (e) => {
                const key = e.key.toLowerCase();
                if (key in keys) {
                    keys[key] = true;
                    e.preventDefault();
                }
            };
            
            const onKeyUp = (e) => {
                const key = e.key.toLowerCase();
                if (key in keys) {
                    keys[key] = false;
                    e.preventDefault();
                }
            };
            
            domElement.addEventListener('mousedown', onMouseDown);
            domElement.addEventListener('mousemove', (e) => {
                if (isPointerLocked && typeof window.cancelFollowAndOrbit === 'function') window.cancelFollowAndOrbit();
                onMouseMove(e);
                
                if (renderer && camera) {
                    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                }
                window.lastMouseX = e.clientX;
                window.lastMouseY = e.clientY;
            });
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('mozpointerlockchange', onPointerLockChange);
            document.addEventListener('webkitpointerlockchange', onPointerLockChange);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            const cachedForward = new THREE.Vector3(0, 0, -1);
            const cachedRight = new THREE.Vector3(1, 0, 0);
            const cachedUp = new THREE.Vector3(0, 1, 0);
            const cachedMoveVector = new THREE.Vector3(0, 0, 0);
            const cachedTarget = new THREE.Vector3(0, 0, 0);
            
            this.update = function(deltaSeconds) {
                const dt = (typeof deltaSeconds === 'number' && isFinite(deltaSeconds)) ? Math.max(0, deltaSeconds) : (1 / 60);
                const hasMovement = keys.w || keys.a || keys.s || keys.d || keys.q || keys.e;
                
                if (this.fixedAtGalacticCenter) {
                    this.positionInt.x = 0;
                    this.positionInt.y = 0;
                    this.positionInt.z = 0;
                    camera.position.set(0, 0, 0);
                }
                
                if (hasMovement && !this.fixedAtGalacticCenter) {
                    cachedForward.set(0, 0, -1);
                    cachedRight.set(1, 0, 0);
                    cachedUp.set(0, 1, 0);
                    
                    cachedForward.applyQuaternion(this.quaternion);
                    cachedRight.applyQuaternion(this.quaternion);
                    cachedUp.applyQuaternion(this.quaternion);
                    
                    const forwardInt = HighPrecisionMath.vec3FloatToInt(cachedForward);
                    const rightInt = HighPrecisionMath.vec3FloatToInt(cachedRight);
                    const upInt = HighPrecisionMath.vec3FloatToInt(cachedUp);
                    
                    let moveVecInt = { x: 0, y: 0, z: 0 };
                    
                    if (keys.w) moveVecInt = HighPrecisionMath.Int.addVectors(moveVecInt, forwardInt);
                    if (keys.s) moveVecInt = HighPrecisionMath.Int.subtractVectors(moveVecInt, forwardInt);
                    if (keys.a) moveVecInt = HighPrecisionMath.Int.subtractVectors(moveVecInt, rightInt);
                    if (keys.d) moveVecInt = HighPrecisionMath.Int.addVectors(moveVecInt, rightInt);
                    if (keys.q) moveVecInt = HighPrecisionMath.Int.addVectors(moveVecInt, upInt);
                    if (keys.e) moveVecInt = HighPrecisionMath.Int.subtractVectors(moveVecInt, upInt);
                    
                    // å½’ä¸€åŒ–ç§»åŠ¨å‘é‡ï¼ˆæ•´æ•°ï¼‰- ä½¿ç”¨æ•´æ•°ç‰ˆæœ¬
                    moveVecInt = HighPrecisionMath.Int.normalizeVector(moveVecInt);
                    
                    // è®¡ç®—æœ€ç»ˆé€Ÿåº¦ï¼ˆæ•´æ•°ï¼‰
                    // moveSpeedæ˜¯æ•´æ•°ï¼ˆSCALEé‡çº§ï¼‰ï¼Œmultiplierè½¬æ¢ä¸ºæ•´æ•°åä¹Ÿæ˜¯SCALEé‡çº§
                    // finalSpeed = moveSpeed * mult1 * mult2 * mult3ï¼Œéœ€è¦é™¤ä»¥SCALE^3å¾—åˆ°SCALEé‡çº§çš„ç»“æœ
                    const speedMult1 = this.speedMultiplier1 ? HighPrecisionMath.toInt(this.speedMultiplier1) : HighPrecisionMath.SCALE;
                    const speedMult2 = this.speedMultiplier2 ? HighPrecisionMath.toInt(this.speedMultiplier2) : HighPrecisionMath.SCALE;
                    const speedMult3 = this.speedMultiplier3 ? HighPrecisionMath.toInt(this.speedMultiplier3) : HighPrecisionMath.SCALE;
                    // finalSpeedPerSecInt = (moveSpeed * mult1 * mult2 * mult3) / SCALE^3    ï¼ˆSCALEé‡çº§ï¼Œå•ä½/ç§’ï¼‰
                    const finalSpeedPerSecInt = Math.round((this.moveSpeed * speedMult1 * speedMult2 * speedMult3) / (HighPrecisionMath.SCALE * HighPrecisionMath.SCALE * HighPrecisionMath.SCALE));
                    
                    // å°†â€œå•ä½/ç§’â€è½¬æ¢ä¸ºâ€œæœ¬å¸§ä½ç§»ï¼ˆå•ä½/å¸§ï¼‰â€
                    // dtInt = dt * SCALE
                    const dtInt = HighPrecisionMath.toInt(dt);
                    // finalSpeedInt = (finalSpeedPerSecInt * dtInt) / SCALE
                    const finalSpeedInt = Math.round((finalSpeedPerSecInt * dtInt) / HighPrecisionMath.SCALE);
                    
                    // åº”ç”¨é€Ÿåº¦ï¼ˆæ•´æ•°ï¼‰- ä½¿ç”¨æ•´æ•°ç‰ˆæœ¬
                    const deltaPosInt = HighPrecisionMath.Int.multiplyScalar(moveVecInt, finalSpeedInt);
                    
                    // æ›´æ–°ä½ç½®ï¼ˆæ•´æ•°ï¼‰
                    this.positionInt.x += deltaPosInt.x;
                    this.positionInt.y += deltaPosInt.y;
                    this.positionInt.z += deltaPosInt.z;
                }
                
                // å°†æ•´æ•°ä½ç½®è½¬æ¢ä¸ºæµ®ç‚¹æ•°å¹¶è®¾ç½®åˆ°ç›¸æœº
                camera.position.set(
                    HighPrecisionMath.toFloat(this.positionInt.x),
                    HighPrecisionMath.toFloat(this.positionInt.y),
                    HighPrecisionMath.toFloat(this.positionInt.z)
                );
                
                // ç›´æ¥ä½¿ç”¨å››å…ƒæ•°è®¾ç½®ç›¸æœºæ—‹è½¬ï¼Œé¿å…ä½¿ç”¨lookAtå¯¼è‡´çš„ç´¯ç§¯è¯¯å·®
                camera.quaternion.copy(this.quaternion);
            };
            
            this.getState = function() {
                return {
                    position: {
                        x: HighPrecisionMath.toFloat(this.positionInt.x),
                        y: HighPrecisionMath.toFloat(this.positionInt.y),
                        z: HighPrecisionMath.toFloat(this.positionInt.z)
                    },
                    positionInt: {
                        x: this.positionInt.x,
                        y: this.positionInt.y,
                        z: this.positionInt.z
                    },
                    quaternion: this.quaternion.clone(),
                    highPrecisionMode: this.highPrecisionMode
                };
            };
            
            this.setState = function(state) {
                if (state) {
                    if (state.positionInt) {
                        // ä¼˜å…ˆä½¿ç”¨æ•´æ•°ä½ç½®
                        this.positionInt.x = state.positionInt.x;
                        this.positionInt.y = state.positionInt.y;
                        this.positionInt.z = state.positionInt.z;
                        camera.position.set(
                            HighPrecisionMath.toFloat(this.positionInt.x),
                            HighPrecisionMath.toFloat(this.positionInt.y),
                            HighPrecisionMath.toFloat(this.positionInt.z)
                        );
                    } else if (state.position) {
                        // å…¼å®¹æµ®ç‚¹ä½ç½®
                        this.positionInt.x = HighPrecisionMath.toInt(state.position.x);
                        this.positionInt.y = HighPrecisionMath.toInt(state.position.y);
                        this.positionInt.z = HighPrecisionMath.toInt(state.position.z);
                        camera.position.copy(state.position);
                    }
                    if (state.quaternion) {
                        this.quaternion.copy(state.quaternion);
                        this.quaternion.normalize();
                    } else if (state.yaw !== undefined || state.pitch !== undefined) {
                        // å‘åå…¼å®¹ï¼šå¦‚æœæä¾›äº† yaw/pitchï¼Œè½¬æ¢ä¸ºå››å…ƒæ•°
                        const yaw = state.yaw !== undefined ? HighPrecisionMath.normalizeAngle(state.yaw) : 0;
                        const pitch = state.pitch !== undefined ? HighPrecisionMath.normalizeAngle(state.pitch) : 0;
                        // å…ˆç»•Yè½´æ—‹è½¬yawï¼Œå†ç»•Xè½´æ—‹è½¬pitch
                        this.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                        const pitchQuat = new THREE.Quaternion();
                        const xAxis = new THREE.Vector3(1, 0, 0);
                        xAxis.applyQuaternion(this.quaternion);
                        pitchQuat.setFromAxisAngle(xAxis, pitch);
                        this.quaternion.multiplyQuaternions(pitchQuat, this.quaternion);
                        this.quaternion.normalize();
                    }
                    if (state.highPrecisionMode !== undefined) {
                        this.highPrecisionMode = state.highPrecisionMode;
                    }
                }
            };
            
            this.setHighPrecisionMode = function(enabled) {
                this.highPrecisionMode = enabled;
            };
            
            this.setPosition = function(x, y, z) {
                // è½¬æ¢ä¸ºæ•´æ•°ä½ç½®
                this.positionInt.x = HighPrecisionMath.toInt(x);
                this.positionInt.y = HighPrecisionMath.toInt(y);
                this.positionInt.z = HighPrecisionMath.toInt(z);
                camera.position.set(x, y, z);
            };
            
            this.setRotation = function(yaw, pitch) {
                // å°† yaw/pitch è½¬æ¢ä¸ºå››å…ƒæ•°
                const normalizedYaw = HighPrecisionMath.normalizeAngle(yaw);
                const normalizedPitch = HighPrecisionMath.normalizeAngle(pitch);
                // å…ˆç»•Yè½´æ—‹è½¬yawï¼Œå†ç»•Xè½´æ—‹è½¬pitch
                this.quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), normalizedYaw);
                const pitchQuat = new THREE.Quaternion();
                const xAxis = new THREE.Vector3(1, 0, 0);
                xAxis.applyQuaternion(this.quaternion);
                pitchQuat.setFromAxisAngle(xAxis, normalizedPitch);
                this.quaternion.multiplyQuaternions(pitchQuat, this.quaternion);
                this.quaternion.normalize();
            };
        };
    </script>
    <script>
        let scene, camera, renderer, controls;
        let glowGeometry, glowMaterial, glowPoints;
        let solidGeometry, solidMaterial, solidPoints;
        let starData = [];
        let currentLimit = 1000000;
        let starSize = 1.0;
        let brightness = 1.0;
        let rotationSpeed = 0;
        let frameCount = 0;
        let lastTime = performance.now();
        let speedMultiplier1 = 0.4;
        let speedMultiplier2 = 1.0;
        let speedMultiplier3 = 1.0;
        let isAnimating = false;
        let animationId = null;
        let isFollowing = false;
        
        // è‡ªåŠ¨æ¼«æ¸¸ç›¸å…³å˜é‡
        let autoTourActive = false;
        let autoTourPaused = false;
        let autoTourCurrentIndex = 0;
        let autoTourLastIndex = -1; // ä¸Šä¸€æ¬¡è‡ªåŠ¨æ¼«æ¸¸çš„æ’æ˜Ÿç´¢å¼•
        let autoTourMode = 'forward'; // 'forward' | 'backward' | 'random'
        let autoTourStartTime = null; // å¼€å§‹ç¯ç»•æ—¶çš„æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
        const AUTO_TOUR_ORBIT_DURATION = 30000; // ç¯ç»•30ç§’ååˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ’æ˜Ÿ
        
        // åœ°çƒå›¾æ ‡ç›¸å…³å˜é‡
        let earthGlobeIcon = null;
        let raycaster = null;
        let mouse = new THREE.Vector2();
        const EARTH_ICON_BASE_SIZE = 48; // åŸºç¡€å¤§å°ï¼ˆåƒç´ ï¼‰
        const EARTH_ICON_HOVER_SIZE = 96; // æ‚¬åœæ—¶çš„å¤§å°ï¼ˆåƒç´ ï¼Œ2å€ï¼‰
        const EARTH_ICON_FAR_SIZE = 72; // è¿œç¦»æ—¶çš„å¤§å°ï¼ˆåƒç´ ï¼‰
        const BUTTON_SHOW_DISTANCE = 150; // æ˜¾ç¤ºæŒ‰é’®çš„è·ç¦»é˜ˆå€¼
        const BUTTON_HIDE_DISTANCE = 200; // éšè—æŒ‰é’®çš„è·ç¦»é˜ˆå€¼
        const BUTTON_HIDE_DELAY = 1000; // å»¶è¿Ÿæ”¶å›æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰- 1ç§’
        let buttonHideTimer = null; // å»¶è¿Ÿæ”¶å›å®šæ—¶å™¨
        let isHoveringSmallButtons = false; // æ˜¯å¦æ‚¬åœåœ¨å°æŒ‰é’®ä¸Š
        let shouldHideButtonsAfterDelay = false; // å»¶è¿Ÿåæ˜¯å¦åº”è¯¥éšè—æŒ‰é’®ï¼ˆç”¨äºè§¦å‘åŠ¨ç”»ï¼‰
        // é¢æ¿å¹³æ»‘ç§»åŠ¨åŠ¨ç”»
        let panelAnimationId = null; // é¢æ¿åŠ¨ç”»ID
        let panelAnimationTargets = new Map(); // å­˜å‚¨é¢æ¿åŠ¨ç”»ç›®æ ‡ {panel: {targetRight, targetBottom, currentRight, currentBottom}}
        // è‡ªå®šä¹‰ç¼“åŠ¨å‡½æ•°ï¼šæ…¢ -> çªç„¶å¿« -> æ…¢
        // è¿”å›é€Ÿåº¦å€æ•°ï¼ˆ0-1ä¹‹é—´ï¼Œå€¼è¶Šå¤§é€Ÿåº¦è¶Šå¿«ï¼‰
        function customEasing(t) {
            // t æ˜¯ 0-1 çš„è¿›åº¦å€¼
            // ä½¿ç”¨åˆ†æ®µå‡½æ•°å®ç°ï¼šæ…¢ -> çªç„¶å¿« -> æ…¢
            if (t < 0.25) {
                // å‰25%ï¼šæ…¢é€Ÿå¼€å§‹ï¼ˆé€Ÿåº¦é€æ¸å¢åŠ ï¼‰
                return 0.3 + 0.2 * (t / 0.25); // ä»0.3åˆ°0.5
            } else if (t < 0.75) {
                // ä¸­é—´50%ï¼šçªç„¶å¿«é€Ÿï¼ˆé€Ÿåº¦æœ€å¿«ï¼‰
                return 0.5 + 0.4 * ((t - 0.25) / 0.5); // ä»0.5åˆ°0.9ï¼Œä¸­é—´è¾¾åˆ°å³°å€¼
            } else {
                // å25%ï¼šæ…¢é€Ÿç»“æŸï¼ˆé€Ÿåº¦é€æ¸å‡æ…¢ï¼‰
                const t3 = (t - 0.75) / 0.25;
                return 0.9 - 0.4 * t3; // ä»0.9åˆ°0.5
            }
        }
        
        // åŠ¨ç”»é€Ÿåº¦ï¼ˆä½¿ç”¨ç¼“åŠ¨å‡½æ•°ï¼‰
        const ANIMATION_SPEED_BASE = 0.08; // åŸºç¡€é€Ÿåº¦ï¼ˆé™ä½ä»¥è®©åŠ¨ç”»æ›´æ˜æ˜¾ï¼‰
        
        // ç”¨æˆ·äº¤äº’æ‰“æ–­ï¼šåœæ­¢è·Ÿè¸ª/ç¯ç»•
        function cancelFollowAndOrbit() {
            if (isAnimating && animationId) {
                cancelAnimationFrame(animationId);
            }
            isAnimating = false;
            animationId = null;
            isFollowing = false;
        }
        // æš´éœ²åˆ°å…¨å±€ï¼Œä¾¿äºæ§åˆ¶å™¨äº‹ä»¶è®¿é—®
        window.cancelFollowAndOrbit = cancelFollowAndOrbit;
        let octree = null; // å…«å‰æ ‘ç”¨äºå¿«é€ŸæŸ¥æ‰¾æœ€è¿‘æ’æ˜Ÿ
        let starPositions = []; // ç¼“å­˜æ’æ˜Ÿä½ç½®ï¼Œé¿å…é‡å¤è®¡ç®—
        let lastNearestStarUpdate = 0;
        const NEAREST_STAR_UPDATE_INTERVAL = 100; // æ¯100msæ›´æ–°ä¸€æ¬¡æœ€è¿‘æ’æ˜Ÿä¿¡æ¯
        let orbitLine = null; // è½¨é“çº¿å¯¹è±¡
        let starMeshes = new Map(); // å­˜å‚¨å·²è½¬æ¢ä¸ºmeshçš„æ’æ˜Ÿ {starIndex: mesh}
        let convertedToMeshStars = new Set(); // å·²è½¬æ¢ä¸ºmeshçš„æ’æ˜Ÿç´¢å¼•é›†åˆ
        let currentFocusedStarIndex = -1; // å½“å‰èšç„¦çš„æ’æ˜Ÿç´¢å¼•
        const MESH_CONVERSION_DISTANCE = 0.005; // è½¬æ¢ä¸ºmeshçš„è·ç¦»é˜ˆå€¼ï¼ˆUIæ˜¾ç¤º50ï¼‰
        
        // æ–‡å­—å¼¹å‡ºç³»ç»Ÿ
        const textSprites = [];
        const textPool = [
            'ä»Šæ—¥é£æŸ”æ—¥æš–ï¼Œ',
            'å²æœˆä¸ºä½ åœç¬”å†™è¯—ã€‚',
            'ä¸€å²ä¸€ç¤¼ï¼Œä¸€å¯¸æ¬¢å–œï¼Œ',
            'æ˜Ÿå­è½åœ¨ä½ çœ¼é‡Œï¼Œ',
            'æ˜¯äººé—´æœ€äº®çš„è´ºè¯ã€‚',
            'æ„¿ä½ æ­¤åå±±é«˜æ°´é•¿ï¼Œ',
            'çš†æœ‰æ¸…é£ä½œä¼´ï¼›',
            'æ„¿ä½ å¿ƒæ€€çƒ­æœ›ï¼Œ',
            'å¸¸å–œè€Œæ— å¿§ï¼Œ',
            'å²å²å¹´å¹´ã€‚'
        ];
        let textSpawnTimer = 0;
        const textSpawnInterval = 2.0;
        const TEXT_SPAWN_DISTANCE = 0.1;
        const starTextIndexMap = new Map();
        
        // åˆ›å»ºæ–‡å­—ç²¾çµ
        function createTextSprite(text, position) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;
            
            // ç»˜åˆ¶æ–‡å­—ï¼ˆå¤šå±‚æ•ˆæœï¼Œæ— èƒŒæ™¯ï¼‰
            const fontSize = text.length <= 2 ? 20 : 15;
            context.font = `Bold ${fontSize}px 'Microsoft YaHei', 'SimHei', Arial, sans-serif`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // å¤–å‘å…‰
            context.shadowColor = 'rgba(102, 126, 234, 1)';
            context.shadowBlur = 40;
            context.fillStyle = '#ffffff';
            context.fillText(text, 256, 128);
            
            // å†…å‘å…‰
            context.shadowColor = 'rgba(240, 147, 251, 0.8)';
            context.shadowBlur = 20;
            context.fillText(text, 256, 128);
            
            // ä¸»æ–‡å­—
            context.shadowColor = 'transparent';
            context.fillStyle = '#ffffff';
            context.fillText(text, 256, 128);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                opacity: 1.0
            });
            
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.1, 0.05, 1); // å¤§å¹…ç¼©å°
            // è®©æ–‡å­—ä»æ›´é è¿‘æ’æ˜Ÿçš„ä½ç½®å¼¹å‡ºï¼ˆåœ¨ç›¸æœºå’Œæ’æ˜Ÿä¹‹é—´ï¼Œæ›´é è¿‘æ’æ˜Ÿï¼‰
            const textPosition = position.clone();
            sprite.position.copy(textPosition);
            
            // éšæœºåˆå§‹é€Ÿåº¦æ–¹å‘ï¼ˆé€Ÿåº¦å¤§å¹…å‡å°ï¼Œè®©æ–‡å­—æ›´é è¿‘ï¼‰
            const angle = Math.random() * Math.PI * 2;
            const elevation = (Math.random() - 0.5) * Math.PI * 0.2; // è¿›ä¸€æ­¥å‡å°è§’åº¦èŒƒå›´
            const speed = 0.002 + Math.random() * 0.004; // é€Ÿåº¦æé«˜2å€
            sprite.userData = {
                velocity: new THREE.Vector3(
                    Math.cos(angle) * Math.cos(elevation) * speed,
                    Math.sin(elevation) * speed,
                    Math.sin(angle) * Math.cos(elevation) * speed
                ),
                life: 0,
                maxLife: 4.5, // ç”Ÿå‘½å‘¨æœŸæé«˜3å€
                text: text,
                rotationSpeed: (Math.random() - 0.5) * 1.5, // å‡å°æ—‹è½¬é€Ÿåº¦
                initialSpeed: speed // è®°å½•åˆå§‹é€Ÿåº¦ï¼Œç”¨äºè¡°å‡
            };
            
            scene.add(sprite);
            textSprites.push(sprite);
            return sprite;
        }
        
        // æ›´æ–°æ–‡å­—ç²¾çµ
        function updateTextSprites(deltaTime) {
            for (let i = textSprites.length - 1; i >= 0; i--) {
                const sprite = textSprites[i];
                const data = sprite.userData;
                
                // æ›´æ–°ç”Ÿå‘½å‘¨æœŸ
                data.life += deltaTime;
                const lifeRatio = data.life / data.maxLife;
                
                // æ›´æ–°ä½ç½®ï¼ˆé€Ÿåº¦é€æ¸è¡°å‡ï¼Œè®©æ–‡å­—ä¸ä¼šé£å¤ªè¿œï¼‰
                const velocity = data.velocity;
                // é€Ÿåº¦è¡°å‡ï¼šéšç€ç”Ÿå‘½å‘¨æœŸå¢åŠ ï¼Œé€Ÿåº¦é€æ¸å‡å°
                const speedDecay = Math.max(0.3, 1.0 - lifeRatio * 0.7); // é€Ÿåº¦è¡°å‡åˆ°30%
                sprite.position.x += velocity.x * deltaTime * speedDecay;
                sprite.position.y += velocity.y * deltaTime * speedDecay;
                sprite.position.z += velocity.z * deltaTime * speedDecay;
                
                // è®¡ç®—åˆ°ç›¸æœºçš„è·ç¦»ï¼Œæ ¹æ®è·ç¦»è°ƒæ•´å¤§å°
                const distance = camera.position.distanceTo(sprite.position);
                const baseScale = 0.1; // å¤§å¹…å‡å°åŸºç¡€ç¼©æ”¾
                const distanceScale = Math.max(0.2, Math.min(0.3, 1.0 / distance)); // å¤§å¹…å‡å°è·ç¦»ç¼©æ”¾èŒƒå›´
                
                // æ·¡å‡ºæ•ˆæœ
                sprite.material.opacity = 1.0 - lifeRatio;
                
                // ç¼©æ”¾æ•ˆæœ
                let scale = 1.0;
                if (lifeRatio < 0.2) {
                    scale = 0.3 + lifeRatio * 3.5;
                } else if (lifeRatio < 0.6) {
                    scale = 1.0;
                } else {
                    scale = 1.0 - (lifeRatio - 0.6) * 1.25;
                }
                
                const finalScale = baseScale * distanceScale * scale;
                sprite.scale.set(finalScale, finalScale * 0.5, 1);
                
                // æ·»åŠ æ—‹è½¬
                sprite.rotation.z += deltaTime * data.rotationSpeed;
                
                // ç§»é™¤è¿‡æœŸæ–‡å­—æˆ–è¶…å‡ºè§†é‡å¤ªè¿œçš„æ–‡å­—
                if (data.life >= data.maxLife || distance > 15) {
                    scene.remove(sprite);
                    sprite.material.dispose();
                    sprite.material.map.dispose();
                    textSprites.splice(i, 1);
                }
            }
        }

        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.000000001,  // æå°çš„è¿‘è£å‰ªé¢ï¼Œä½¿ç”¨é«˜ç²¾åº¦è®¡ç®—
                100000
            );
            camera.position.set(0, 0, 500);
            let rendererOptions = { 
                antialias: false,
                powerPreference: "high-performance",
                stencil: false,
                depth: true,
                logarithmicDepthBuffer: true,  // å¯ç”¨å¯¹æ•°æ·±åº¦ç¼“å†²åŒºï¼Œæ”¹å–„å¤§èŒƒå›´åœºæ™¯çš„æ·±åº¦ç²¾åº¦
                preserveDrawingBuffer: false,
                failIfMajorPerformanceCaveat: false
            };
            
            try {
                renderer = new THREE.WebGLRenderer(rendererOptions);
                const gl = renderer.getContext();
                if (!gl) {
                    throw new Error('WebGLä¸Šä¸‹æ–‡åˆ›å»ºå¤±è´¥');
                }
                
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                let isSoftwareRenderer = false;
                let rendererInfo = '';
                const isEdge = navigator.userAgent.includes('Edg');
                
                if (debugInfo) {
                    const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    const rendererName = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    const vendorLower = vendor ? vendor.toLowerCase() : '';
                    const rendererLower = rendererName ? rendererName.toLowerCase() : '';
                    
                    rendererInfo = `${vendor || 'æœªçŸ¥'} - ${rendererName || 'æœªçŸ¥'}`;
                    
                    isSoftwareRenderer = 
                        rendererLower.includes('swiftshader') ||
                        rendererLower.includes('llvmpipe') ||
                        rendererLower.includes('mesa') ||
                        rendererLower.includes('software') ||
                        (vendorLower.includes('google') && rendererLower.includes('swiftshader'));
                    
                    const isIntelGPU = vendorLower.includes('intel');
                    const isIntelIrisXe = rendererLower.includes('iris') || rendererLower.includes('xe');
                    
                    if (isIntelGPU && isIntelIrisXe) {
                        isSoftwareRenderer = false;
                    }
                    
                    if (isSoftwareRenderer) {
                        console.warn('âš ï¸ æ£€æµ‹åˆ°è½¯ä»¶æ¸²æŸ“:', rendererInfo);
                        console.warn('æ€§èƒ½æç¤º: è½¯ä»¶æ¸²æŸ“ä¼šå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚');
                        if (isEdge) {
                            console.warn('Edgeæµè§ˆå™¨è®¾ç½®å»ºè®®ï¼š');
                            console.warn('1. åœ¨åœ°å€æ è¾“å…¥ edge://settings/system');
                            console.warn('2. ç¡®ä¿"ä½¿ç”¨ç¡¬ä»¶åŠ é€Ÿæ¨¡å¼ï¼ˆå¦‚æœå¯ç”¨ï¼‰"å·²å¯ç”¨');
                            console.warn('3. åœ¨ edge://flags ä¸­æœç´¢å¹¶å¯ç”¨:');
                            console.warn('   - "Override software rendering list" (å¿½ç•¥GPUé˜»æ­¢åˆ—è¡¨)');
                            console.warn('   - "Use ANGLE" è®¾ç½®ä¸º "Default" æˆ– "D3D11"');
                            console.warn('4. é‡å¯æµè§ˆå™¨');
                        } else {
                            console.warn('Chromeæµè§ˆå™¨è®¾ç½®å»ºè®®ï¼š');
                            console.warn('1. åœ¨åœ°å€æ è¾“å…¥ chrome://settings/system');
                            console.warn('2. ç¡®ä¿"ä½¿ç”¨ç¡¬ä»¶åŠ é€Ÿæ¨¡å¼ï¼ˆå¦‚æœå¯ç”¨ï¼‰"å·²å¯ç”¨');
                            console.warn('3. åœ¨ chrome://flags ä¸­å¯ç”¨ç¡¬ä»¶åŠ é€Ÿç›¸å…³é€‰é¡¹');
                            console.warn('4. é‡å¯æµè§ˆå™¨');
                        }
                        console.warn('5. æ›´æ–°æ˜¾å¡é©±åŠ¨ç¨‹åºåˆ°æœ€æ–°ç‰ˆæœ¬');
                    } else {
                        console.log('âœ… WebGLç¡¬ä»¶åŠ é€Ÿå·²å¯ç”¨');
                        console.log('æ¸²æŸ“å™¨:', rendererInfo);
                    }
                } else {
                    const rendererParam = gl.getParameter(gl.RENDERER);
                    if (rendererParam) {
                        rendererInfo = rendererParam;
                        const rendererLower = rendererParam.toLowerCase();
                        isSoftwareRenderer = 
                            rendererLower.includes('software') ||
                            rendererLower.includes('swiftshader') ||
                            rendererLower.includes('llvmpipe');
                        
                        if (isSoftwareRenderer) {
                            console.warn('âš ï¸ æ£€æµ‹åˆ°è½¯ä»¶æ¸²æŸ“:', rendererParam);
                            console.warn('æ€§èƒ½æç¤º: è½¯ä»¶æ¸²æŸ“ä¼šå¯¼è‡´æ€§èƒ½ä¸‹é™');
                            if (isEdge) {
                                console.warn('è¯·åœ¨ edge://settings/system ä¸­å¯ç”¨ç¡¬ä»¶åŠ é€Ÿ');
                            }
                        } else {
                            console.log('âœ… WebGLç¡¬ä»¶åŠ é€Ÿå·²å¯ç”¨');
                            console.log('æ¸²æŸ“å™¨:', rendererParam);
                        }
                    }
                }
                
                // æ£€æŸ¥WebGLç‰ˆæœ¬å’Œæ‰©å±•
                const webglVersion = gl.getParameter(gl.VERSION);
                const webglShadingLanguageVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
                console.log('WebGLç‰ˆæœ¬:', webglVersion);
                console.log('ç€è‰²å™¨è¯­è¨€ç‰ˆæœ¬:', webglShadingLanguageVersion);
                
                // æ£€æŸ¥ANGLEåç«¯ï¼ˆEdge/Chromeä½¿ç”¨ï¼‰
                const angleInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (angleInfo) {
                    const unmaskedRenderer = gl.getParameter(angleInfo.UNMASKED_RENDERER_WEBGL);
                    if (unmaskedRenderer) {
                        console.log('ANGLEæ¸²æŸ“å™¨:', unmaskedRenderer);
                    }
                }
                
                renderer.setSize(window.innerWidth, window.innerHeight);
                
                const isIntelIrisXe = (debugInfo && 
                    (gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || '').toLowerCase().includes('intel') &&
                    (gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || '').toLowerCase().includes('iris'));
                
                if (isIntelIrisXe) {
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                } else {
                    renderer.setPixelRatio(1);
                }
                
                renderer.autoClear = true;
                renderer.shadowMap.enabled = false;
                
                document.getElementById('canvas-container').appendChild(renderer.domElement);
            } catch (error) {
                alert('WebGLåˆå§‹åŒ–å¤±è´¥ï¼š' + error.message);
                return;
            }

            if (!renderer || !renderer.domElement) {
                alert('æ¸²æŸ“å™¨åˆå§‹åŒ–å¤±è´¥');
                return;
            }
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = false;
            controls.dampingFactor = 0.05;
            controls.moveSpeed = HighPrecisionMath.toInt(25); // ä½¿ç”¨æ•´æ•°é€Ÿåº¦ï¼ˆé»˜è®¤25ï¼‰
            controls.rotationSpeed = 0.002;
            controls.speedMultiplier1 = speedMultiplier1;
            controls.speedMultiplier2 = speedMultiplier2;
            controls.speedMultiplier3 = speedMultiplier3;
            controls.setHighPrecisionMode(false);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // åˆå§‹åŒ–åœ°çƒå›¾æ ‡
            initEarthGlobeIcon();
            
            // åˆ›å»ºå°„çº¿æ£€æµ‹å™¨ç”¨äºé¼ æ ‡æ‚¬åœæ£€æµ‹ï¼ˆç”¨äº3Dåœºæ™¯ï¼Œä½†å›¾æ ‡æ˜¯2Dçš„ï¼‰
            raycaster = new THREE.Raycaster();

            window.addEventListener('resize', onWindowResize);
        }
        
        // åˆå§‹åŒ–åœ°çƒå›¾æ ‡
        function initEarthGlobeIcon() {
            earthGlobeIcon = document.getElementById('earth-globe-icon');
            if (!earthGlobeIcon) return;
            
            // è®¾ç½®åˆå§‹ä½ç½®ï¼ˆæŒ‰é’®åœ†å¿ƒä½ç½®ï¼‰
            updateEarthGlobeIconPosition(EARTH_ICON_BASE_SIZE);
            
            // åˆå§‹åŒ–æ‚¬åœçŠ¶æ€
            window.isHoveringEarthIcon = false;
            
            // æ·»åŠ é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨ç”¨äºæ‚¬åœæ£€æµ‹
            earthGlobeIcon.addEventListener('mouseenter', (e) => {
                window.isHoveringEarthIcon = true;
                // console.log('Mouse enter earth icon');
            });
            earthGlobeIcon.addEventListener('mouseleave', (e) => {
                window.isHoveringEarthIcon = false;
                // console.log('Mouse leave earth icon');
            });
            
            // ä¹Ÿç›‘å¬å›¾æ ‡å†…éƒ¨çš„iå…ƒç´ 
            const iconElement = earthGlobeIcon.querySelector('i');
            if (iconElement) {
                iconElement.addEventListener('mouseenter', () => {
                    window.isHoveringEarthIcon = true;
                });
                iconElement.addEventListener('mouseleave', () => {
                    window.isHoveringEarthIcon = false;
                });
            }
        }
        
        // æ›´æ–°åœ°çƒå›¾æ ‡ä½ç½®ï¼ˆå§‹ç»ˆåœ¨æŒ‰é’®åœ†å¿ƒçš„å±å¹•ä½ç½®ï¼‰
        function updateEarthGlobeIconPosition(iconSize = EARTH_ICON_BASE_SIZE) {
            if (!earthGlobeIcon) return;
            
            // æŒ‰é’®å®¹å™¨ä½ç½®ï¼šright: 20px, bottom: 20px
            // æŒ‰é’®å®¹å™¨transform: translate(-60px, -60px)
            // æ‰€ä»¥åœ†å¿ƒåœ¨ï¼šright: 20-60=-40px, bottom: 20-60=-40px
            // è½¬æ¢ä¸ºleft/topï¼šleft = window.innerWidth - 20 + 60, top = window.innerHeight - 20 + 60
            
            // åœ°çƒå›¾æ ‡ä¹Ÿä½¿ç”¨ç›¸åŒçš„å®šä½æ–¹å¼ï¼šright: 20px, bottom: 20px, transform: translate(-60px, -60px)
            // æ‰€ä»¥å›¾æ ‡æœ¬èº«å·²ç»åœ¨åœ†å¿ƒä½ç½®ï¼Œåªéœ€è¦è°ƒæ•´å†…éƒ¨å›¾æ ‡çš„å¤§å°å’Œä½ç½®
            // ç”±äºä½¿ç”¨äº†transformï¼Œä¸éœ€è¦è®¾ç½®left/topï¼Œåªéœ€è¦ç¡®ä¿å›¾æ ‡å±…ä¸­
            const iconElement = earthGlobeIcon.querySelector('i');
            if (iconElement) {
                // å›¾æ ‡å·²ç»é€šè¿‡transformå®šä½åœ¨åœ†å¿ƒï¼Œåªéœ€è¦è°ƒæ•´å¤§å°
                // ä½ç½®ä¼šè‡ªåŠ¨å±…ä¸­ï¼Œå› ä¸ºtransform-originæ˜¯center
            }
        }
        
        // æ›´æ–°åœ°çƒå›¾æ ‡äº¤äº’ï¼ˆæ£€æµ‹è·ç¦»å’Œé¼ æ ‡æ‚¬åœï¼‰
        function updateEarthSphereInteraction() {
            if (!earthGlobeIcon || !camera) return;
            
            // å›¾æ ‡ä½ç½®ä¼šåœ¨æ›´æ–°å¤§å°æ—¶è‡ªåŠ¨è°ƒæ•´ï¼Œè¿™é‡Œä¸éœ€è¦å•ç‹¬æ›´æ–°
            
            // è®¡ç®—ç›¸æœºåˆ°æŒ‰é’®åœ†å¿ƒçš„3Dè·ç¦»ï¼ˆä½¿ç”¨æŒ‰é’®åœ†å¿ƒçš„3Dä½ç½®ï¼‰
            const buttonCenterX = window.innerWidth - 20 + 60;
            const buttonCenterY = window.innerHeight - 20 + 60;
            const ndcX = (buttonCenterX / window.innerWidth) * 2 - 1;
            const ndcY = -(buttonCenterY / window.innerHeight) * 2 + 1;
            const vector = new THREE.Vector3(ndcX, ndcY, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const button3DPos = camera.position.clone().add(dir.multiplyScalar(100));
            const distance = camera.position.distanceTo(button3DPos);
            
            // æ£€æµ‹é¼ æ ‡æ‚¬åœï¼ˆä½¿ç”¨äº‹ä»¶ç›‘å¬å™¨çš„çŠ¶æ€ï¼‰
            const isHovering = window.isHoveringEarthIcon === true;
            
            // æ ¹æ®è·ç¦»å’Œæ‚¬åœçŠ¶æ€æ§åˆ¶å›¾æ ‡å’ŒæŒ‰é’®
            let targetIconSize = EARTH_ICON_BASE_SIZE;
            let targetButtonScale = 0.0; // æŒ‰é’®åŸºç¡€ç¼©æ”¾ï¼ˆ0è¡¨ç¤ºå®Œå…¨éšè—ï¼‰
            let targetButtonOpacity = 0.0; // æŒ‰é’®åŸºç¡€é€æ˜åº¦ï¼ˆ0è¡¨ç¤ºå®Œå…¨éšè—ï¼‰
            let shouldHideButtons = false; // æ˜¯å¦åº”è¯¥éšè—æŒ‰é’®
            
            // è°ƒè¯•ä¿¡æ¯
            // console.log('Hover check:', { isHovering, isHoveringSmallButtons, distance });
            
            if (isHovering || isHoveringSmallButtons) {
                // æ‚¬åœåœ¨å¤§æŒ‰é’®æˆ–å°æŒ‰é’®ä¸Šæ—¶ï¼šå›¾æ ‡æ”¾å¤§2å€ï¼ŒæŒ‰é’®å¼¹å‡º
                // å–æ¶ˆå»¶è¿Ÿæ”¶å›å®šæ—¶å™¨å’Œæ ‡å¿—
                if (buttonHideTimer) {
                    clearTimeout(buttonHideTimer);
                    buttonHideTimer = null;
                }
                shouldHideButtonsAfterDelay = false;
                targetIconSize = EARTH_ICON_HOVER_SIZE;
                targetButtonScale = 1.0;
                targetButtonOpacity = 1.0;
                shouldHideButtons = false;
                // å¦‚æœé¢æ¿å¯è§ï¼Œå°†é¢æ¿æ¢å¤åˆ°å¯¹åº”çš„å°æŒ‰é’®æ—è¾¹
                restorePanelsToButtons();
            } else if (distance > BUTTON_HIDE_DISTANCE) {
                // è¿œç¦»æ—¶ï¼šå›¾æ ‡æ”¾å¤§ï¼ŒæŒ‰é’®å¼¹å‡º
                // å–æ¶ˆå»¶è¿Ÿæ”¶å›å®šæ—¶å™¨å’Œæ ‡å¿—
                if (buttonHideTimer) {
                    clearTimeout(buttonHideTimer);
                    buttonHideTimer = null;
                }
                shouldHideButtonsAfterDelay = false;
                targetIconSize = EARTH_ICON_FAR_SIZE;
                targetButtonScale = 1.0;
                targetButtonOpacity = 1.0;
                shouldHideButtons = false;
                // å¦‚æœé¢æ¿å¯è§ï¼Œå°†é¢æ¿æ¢å¤åˆ°å¯¹åº”çš„å°æŒ‰é’®æ—è¾¹
                restorePanelsToButtons();
            } else if (distance < BUTTON_SHOW_DISTANCE) {
                // æ¥è¿‘æ—¶ï¼šåº”è¯¥éšè—æŒ‰é’®ï¼Œä½†éœ€è¦å»¶è¿Ÿ
                shouldHideButtons = true;
                // å¦‚æœè¿˜æ²¡æœ‰å¯åŠ¨å®šæ—¶å™¨ï¼Œå¯åŠ¨å»¶è¿Ÿæ”¶å›å®šæ—¶å™¨
                if (!buttonHideTimer) {
                    buttonHideTimer = setTimeout(() => {
                        // å»¶è¿Ÿåï¼Œå¦‚æœä»ç„¶åº”è¯¥éšè—ä¸”æ²¡æœ‰æ‚¬åœåœ¨å°æŒ‰é’®ä¸Šï¼Œåˆ™è®¾ç½®æ ‡å¿—è§¦å‘åŠ¨ç”»
                        if (!isHoveringSmallButtons && !window.isHoveringEarthIcon) {
                            shouldHideButtonsAfterDelay = true;
                        }
                        buttonHideTimer = null;
                    }, BUTTON_HIDE_DELAY);
                }
                // æ£€æŸ¥æ˜¯å¦åº”è¯¥éšè—ï¼ˆå»¶è¿Ÿåï¼‰
                if (shouldHideButtonsAfterDelay && !isHoveringSmallButtons && !window.isHoveringEarthIcon) {
                    // å»¶è¿Ÿæ—¶é—´å·²åˆ°ï¼Œå¼€å§‹åŠ¨ç”»æ”¶å›
                    targetIconSize = EARTH_ICON_BASE_SIZE;
                    targetButtonScale = 0.0;
                    targetButtonOpacity = 0.0;
                    // å°†å¡ç‰‡ç§»åŠ¨åˆ°å¤§æŒ‰é’®æ—è¾¹
                    movePanelsToEarthIcon();
                } else {
                    // å»¶è¿ŸæœŸé—´ä¿æŒå½“å‰çŠ¶æ€ï¼ˆä¸ç«‹å³éšè—ï¼‰
                    // è·å–å½“å‰æŒ‰é’®çŠ¶æ€
                    const cornerButtons = document.getElementById('corner-buttons');
                    if (cornerButtons) {
                        const firstButton = cornerButtons.querySelector('.corner-switch');
                        if (firstButton) {
                            const currentTransform = firstButton.style.transform || '';
                            const currentScaleMatch = currentTransform.match(/scale\(([\d.]+)\)/);
                            const currentScale = currentScaleMatch ? parseFloat(currentScaleMatch[1]) : 0.0;
                            const currentOpacity = parseFloat(firstButton.style.opacity) || 0.0;
                            // å¦‚æœæŒ‰é’®å·²ç»æ˜¾ç¤ºï¼Œä¿æŒæ˜¾ç¤ºçŠ¶æ€ï¼ˆç­‰å¾…å®šæ—¶å™¨ï¼‰
                            if (currentScale > 0.1 || currentOpacity > 0.1) {
                                targetButtonScale = currentScale;
                                targetButtonOpacity = currentOpacity;
                                targetIconSize = EARTH_ICON_HOVER_SIZE; // ä¿æŒæ”¾å¤§çŠ¶æ€
                            } else {
                                // å¦‚æœæŒ‰é’®å·²ç»éšè—ï¼Œåˆ™ä¿æŒéšè—
                                targetIconSize = EARTH_ICON_BASE_SIZE;
                                targetButtonScale = 0.0;
                                targetButtonOpacity = 0.0;
                            }
                        }
                    }
                }
            } else {
                // ä¸­é—´çŠ¶æ€ï¼šæ ¹æ®è·ç¦»æ¸å˜
                // å–æ¶ˆå»¶è¿Ÿæ”¶å›å®šæ—¶å™¨å’Œæ ‡å¿—
                if (buttonHideTimer) {
                    clearTimeout(buttonHideTimer);
                    buttonHideTimer = null;
                }
                shouldHideButtonsAfterDelay = false;
                const ratio = (distance - BUTTON_SHOW_DISTANCE) / (BUTTON_HIDE_DISTANCE - BUTTON_SHOW_DISTANCE);
                // ä»æ¥è¿‘åˆ°è¿œç¦»ï¼šå›¾æ ‡é€æ¸æ”¾å¤§ï¼ŒæŒ‰é’®é€æ¸å¼¹å‡º
                targetIconSize = EARTH_ICON_BASE_SIZE + (EARTH_ICON_FAR_SIZE - EARTH_ICON_BASE_SIZE) * ratio;
                targetButtonScale = ratio; // ä»0åˆ°1
                targetButtonOpacity = ratio; // ä»0åˆ°1
            }
            
            // è·å–å›¾æ ‡å…ƒç´ 
            const iconElement = earthGlobeIcon.querySelector('i');
            
            // è®¡ç®—åŠ¨ç”»è¿›åº¦ï¼ˆ0-1ï¼‰
            // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°è®¡ç®—å®é™…é€Ÿåº¦
            let animationProgress = 0;
            if (iconElement && (targetIconSize !== EARTH_ICON_BASE_SIZE || targetButtonScale > 0)) {
                // å¦‚æœæœ‰å˜åŒ–ï¼Œè®¡ç®—è¿›åº¦ï¼ˆåŸºäºå›¾æ ‡å¤§å°ï¼‰
                const currentSize = parseFloat(iconElement.style.fontSize) || EARTH_ICON_BASE_SIZE;
                const startSize = EARTH_ICON_BASE_SIZE;
                const endSize = targetIconSize;
                const totalDiff = Math.abs(endSize - startSize);
                if (totalDiff > 0) {
                    const currentDiff = Math.abs(currentSize - startSize);
                    animationProgress = Math.min(1, currentDiff / totalDiff);
                }
            }
            
            // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°è®¡ç®—é€Ÿåº¦å› å­ï¼ˆè¿”å›0.3-0.9ä¹‹é—´çš„å€¼ï¼‰
            const easingFactor = customEasing(animationProgress);
            // å°†ç¼“åŠ¨å› å­è½¬æ¢ä¸ºé€Ÿåº¦å€æ•°ï¼š0.3 -> 0.5å€é€Ÿåº¦ï¼Œ0.9 -> 2.0å€é€Ÿåº¦
            const speedMultiplier = 0.5 + (easingFactor - 0.3) / (0.9 - 0.3) * 1.5;
            const currentSpeed = ANIMATION_SPEED_BASE * speedMultiplier;
            
            // å¹³æ»‘ç¼©æ”¾å›¾æ ‡ï¼ˆä½¿ç”¨ç¼“åŠ¨é€Ÿåº¦ï¼‰
            if (iconElement) {
                const currentSize = parseFloat(iconElement.style.fontSize) || EARTH_ICON_BASE_SIZE;
                const sizeDiff = targetIconSize - currentSize;
                const newSize = currentSize + sizeDiff * currentSpeed;
                iconElement.style.fontSize = `${newSize}px`;
                // å›¾æ ‡ä½ç½®å·²ç»é€šè¿‡transformå®šä½åœ¨åœ†å¿ƒï¼Œtransform-originç¡®ä¿ç¼©æ”¾æ—¶ä»¥åœ†å¿ƒä¸ºä¸­å¿ƒ
                // ä¸éœ€è¦è°ƒæ•´left/top
            }
            
            // æ§åˆ¶æŒ‰é’®æ˜¾ç¤º/éšè—ï¼ˆä»ä¸­å¿ƒå¼¹å‡ºï¼Œä½¿ç”¨ç¼“åŠ¨é€Ÿåº¦ï¼‰
            const cornerButtons = document.getElementById('corner-buttons');
            if (cornerButtons) {
                const buttons = cornerButtons.querySelectorAll('.corner-switch');
                buttons.forEach(btn => {
                    // ä»CSSä¸­è·å–åŸæœ‰çš„translateå€¼ï¼ˆç›®æ ‡ä½ç½®ï¼‰
                    let targetTranslateX = 0, targetTranslateY = 0;
                    if (btn.id === 'btn-show-stats') {
                        targetTranslateX = 0;
                        targetTranslateY = -88;
                    } else if (btn.id === 'btn-show-auto-tour') {
                        targetTranslateX = -62;
                        targetTranslateY = -62;
                    } else if (btn.id === 'btn-show-list') {
                        targetTranslateX = -88;
                        targetTranslateY = 0;
                    }
                    
                    // è·å–å½“å‰çŠ¶æ€
                    const currentTransform = btn.style.transform || '';
                    const currentScaleMatch = currentTransform.match(/scale\(([\d.]+)\)/);
                    const currentTranslateMatch = currentTransform.match(/translate\(([-\d.]+)px,\s*([-\d.]+)px\)/);
                    const currentScale = currentScaleMatch ? parseFloat(currentScaleMatch[1]) : 0.0;
                    const currentOpacity = parseFloat(btn.style.opacity) || 0.0;
                    const currentTranslateX = currentTranslateMatch ? parseFloat(currentTranslateMatch[1]) : 0;
                    const currentTranslateY = currentTranslateMatch ? parseFloat(currentTranslateMatch[2]) : 0;
                    
                    // ä»ä¸­å¿ƒå¼¹å‡ºï¼štranslateä»(0,0)åˆ°ç›®æ ‡ä½ç½®ï¼Œscaleä»0åˆ°ç›®æ ‡å€¼
                    const targetTranslateXFinal = targetButtonScale > 0 ? targetTranslateX : 0;
                    const targetTranslateYFinal = targetButtonScale > 0 ? targetTranslateY : 0;
                    
                    // å¹³æ»‘è¿‡æ¸¡ï¼ˆä½¿ç”¨ç¼“åŠ¨é€Ÿåº¦ï¼‰
                    const newScale = currentScale + (targetButtonScale - currentScale) * currentSpeed;
                    const newOpacity = currentOpacity + (targetButtonOpacity - currentOpacity) * currentSpeed;
                    const newTranslateX = currentTranslateX + (targetTranslateXFinal - currentTranslateX) * currentSpeed;
                    const newTranslateY = currentTranslateY + (targetTranslateYFinal - currentTranslateY) * currentSpeed;
                    
                    // é™åˆ¶å€¼èŒƒå›´
                    const finalScale = Math.max(0, Math.min(1, newScale));
                    const finalOpacity = Math.max(0, Math.min(1, newOpacity));
                    
                    btn.style.opacity = finalOpacity.toString();
                    btn.style.transform = `translate(${newTranslateX}px, ${newTranslateY}px) scale(${finalScale})`;
                    btn.style.pointerEvents = finalOpacity > 0.5 ? 'auto' : 'none';
                    btn.style.transition = 'none'; // ä½¿ç”¨JavaScriptæ§åˆ¶åŠ¨ç”»ï¼Œä¸ä½¿ç”¨CSS transition
                    btn.style.visibility = finalOpacity > 0.01 ? 'visible' : 'hidden'; // å®Œå…¨éšè—æ—¶ä½¿ç”¨visibility
                });
            }
        }

        function convertToGalactic(ra, dec) {
            const raGP = 192.85948;
            const decGP = 27.12825;
            const lCP = 122.93192;
            const raRad = (ra * Math.PI) / 180;
            const decRad = (dec * Math.PI) / 180;
            const raGPRad = (raGP * Math.PI) / 180;
            const decGPRad = (decGP * Math.PI) / 180;
            const lCPRad = (lCP * Math.PI) / 180;
            const sin_b = Math.sin(decRad) * Math.sin(decGPRad) + 
                         Math.cos(decRad) * Math.cos(decGPRad) * Math.cos(raRad - raGPRad);
            const b = Math.asin(sin_b);
            const cos_b = Math.cos(b);
            const sin_l_minus_lCP = (Math.cos(decRad) * Math.sin(raRad - raGPRad)) / cos_b;
            const cos_l_minus_lCP = (Math.sin(decRad) * Math.cos(decGPRad) - 
                                    Math.cos(decRad) * Math.sin(decGPRad) * Math.cos(raRad - raGPRad)) / cos_b;
            
            let l = Math.atan2(sin_l_minus_lCP, cos_l_minus_lCP) + lCPRad;
            if (l < 0) l += 2 * Math.PI;

            return { l: l * 180 / Math.PI, b: b * 180 / Math.PI };
        }

        function convertTo3D(ra, dec, parallax, l, b) {
            let lRad, bRad;
            if (l !== undefined && b !== undefined) {
                lRad = (l * Math.PI) / 180;
                bRad = (b * Math.PI) / 180;
            } else {
                const galactic = convertToGalactic(ra, dec);
                lRad = (galactic.l * Math.PI) / 180;
                bRad = (galactic.b * Math.PI) / 180;
            }

            let distance = 0;
            if (parallax > 0) {
                distance = 1000 / parallax;
            } else {
                distance = 100;
            }
            
            const scaleFactor = 1;
            const clampedDistance = Math.min(distance * scaleFactor, 2000);
            const x = clampedDistance * Math.cos(bRad) * Math.cos(lRad);
            const y = clampedDistance * Math.cos(bRad) * Math.sin(lRad);
            const z = clampedDistance * Math.sin(bRad);

            return { x, y, z, distance: clampedDistance, galacticB: b };
        }

        // è®¡ç®—æ’æ˜Ÿçš„3Dé€Ÿåº¦å‘é‡ï¼ˆä»è‡ªè¡Œå’Œå¾„å‘é€Ÿåº¦ï¼Œè½¬æ¢åˆ°é“¶æ²³åæ ‡ç³»ï¼‰
        function calculateStarVelocity(star, starPos) {
            // å¦‚æœæ²¡æœ‰é€Ÿåº¦æ•°æ®ï¼Œè¿”å›é›¶å‘é‡
            // ä½¿ç”¨æ›´ä¸¥æ ¼çš„æ£€æŸ¥ï¼šæ£€æŸ¥å­—æ®µæ˜¯å¦å­˜åœ¨ä¸”ä¸ä¸ºnull/undefinedï¼ˆå…è®¸0å€¼ï¼‰
            const hasPmra = star.pmra !== null && star.pmra !== undefined;
            const hasPmdec = star.pmdec !== null && star.pmdec !== undefined;
            const hasRadialVelocity = star.radial_velocity !== null && star.radial_velocity !== undefined;
            
            if (!hasPmra && !hasPmdec && !hasRadialVelocity) {
                return { vx: 0, vy: 0, vz: 0 };
            }

            const distance = starPos.distance || Math.sqrt(starPos.x * starPos.x + starPos.y * starPos.y + starPos.z * starPos.z);
            if (distance <= 0) {
                return { vx: 0, vy: 0, vz: 0 };
            }

            // è½¬æ¢è§’åº¦å•ä½ï¼šmas/yr è½¬ rad/yr
            const pmra = (star.pmra || 0) * Math.PI / (180 * 3600 * 1000); // mas/yr to rad/yr
            const pmdec = (star.pmdec || 0) * Math.PI / (180 * 3600 * 1000); // mas/yr to rad/yr
            
            // å¾„å‘é€Ÿåº¦ï¼škm/s è½¬ å•ä½/å¹´
            // 1 km/s â‰ˆ 1.0227e-6 å…‰å¹´/å¹´ â‰ˆ 0.0000010227 å•ä½/å¹´ï¼ˆå‡è®¾1å•ä½=1å…‰å¹´ï¼‰
            const radialVelocity = (star.radial_velocity || 0) * 0.0000010227;

            // è®¡ç®—èµ¤é“åæ ‡ç³»ä¸­çš„é€Ÿåº¦åˆ†é‡
            const raRad = (star.ra || 0) * Math.PI / 180;
            const decRad = (star.dec || 0) * Math.PI / 180;

            // åˆ‡å‘é€Ÿåº¦çš„æ–¹å‘ï¼ˆåœ¨èµ¤é“åæ ‡ç³»ä¸­ï¼‰
            // RAæ–¹å‘ï¼šæ²¿èµ¤çº¬åœˆï¼Œå‘ä¸œä¸ºæ­£
            const pmraDirection = new THREE.Vector3(-Math.sin(raRad), Math.cos(raRad), 0);
            // DECæ–¹å‘ï¼šæ²¿å­åˆåœˆï¼Œå‘åŒ—ä¸ºæ­£
            const pmdecDirection = new THREE.Vector3(-Math.sin(decRad) * Math.cos(raRad), -Math.sin(decRad) * Math.sin(raRad), Math.cos(decRad));
            
            // è®¡ç®—åˆ‡å‘é€Ÿåº¦å‘é‡ï¼ˆåœ¨èµ¤é“åæ ‡ç³»ä¸­ï¼‰
            const tangentialVelocity = new THREE.Vector3();
            tangentialVelocity.addScaledVector(pmraDirection, distance * pmra * Math.cos(decRad));
            tangentialVelocity.addScaledVector(pmdecDirection, distance * pmdec);

            // å¾„å‘é€Ÿåº¦æ–¹å‘ï¼ˆåœ¨èµ¤é“åæ ‡ç³»ä¸­ï¼Œä»å¤ªé˜³æŒ‡å‘æ’æ˜Ÿï¼‰
            const radialDirection = new THREE.Vector3(
                Math.cos(decRad) * Math.cos(raRad),
                Math.cos(decRad) * Math.sin(raRad),
                Math.sin(decRad)
            );
            const radialVelocityVec = radialDirection.multiplyScalar(radialVelocity);

            // æ€»é€Ÿåº¦å‘é‡ï¼ˆåœ¨èµ¤é“åæ ‡ç³»ä¸­ï¼‰
            const totalVelocityEq = tangentialVelocity.add(radialVelocityVec);

            // å°†é€Ÿåº¦ä»èµ¤é“åæ ‡ç³»è½¬æ¢åˆ°é“¶æ²³åæ ‡ç³»
            // ä½¿ç”¨ä¸ä½ç½®è½¬æ¢ç›¸åŒçš„è½¬æ¢çŸ©é˜µ
            const galactic = convertToGalactic(star.ra, star.dec);
            const lRad = (galactic.l * Math.PI) / 180;
            const bRad = (galactic.b * Math.PI) / 180;
            
            // ç®€åŒ–çš„è½¬æ¢ï¼šå‡è®¾é€Ÿåº¦å‘é‡è¾ƒå°ï¼Œä½¿ç”¨å±€éƒ¨åæ ‡ç³»è½¬æ¢
            // å¯¹äºå°è§’åº¦ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ä½ç½®åæ ‡ç³»çš„æ—‹è½¬
            // è¿™é‡Œä½¿ç”¨ä¸€ä¸ªè¿‘ä¼¼ï¼šå°†é€Ÿåº¦å‘é‡æŠ•å½±åˆ°é“¶æ²³åæ ‡ç³»
            const cosL = Math.cos(lRad);
            const sinL = Math.sin(lRad);
            const cosB = Math.cos(bRad);
            const sinB = Math.sin(bRad);
            
            // è½¬æ¢åˆ°é“¶æ²³åæ ‡ç³»ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼Œé€‚ç”¨äºå°é€Ÿåº¦ï¼‰
            const vx = totalVelocityEq.x * cosL * cosB - totalVelocityEq.y * sinL - totalVelocityEq.z * cosL * sinB;
            const vy = totalVelocityEq.x * sinL * cosB + totalVelocityEq.y * cosL - totalVelocityEq.z * sinL * sinB;
            const vz = totalVelocityEq.x * sinB + totalVelocityEq.z * cosB;

            return { vx, vy, vz };
        }

        // è®¡ç®—å¹¶ç»˜åˆ¶æ’æ˜Ÿè½¨é“
        function calculateAndDrawOrbit(star, starPos) {
            // ä¸´æ—¶ç¦ç”¨è½¨é“çº¿ç»˜åˆ¶
            return;
            // ç§»é™¤æ—§çš„è½¨é“çº¿
            if (orbitLine) {
                try {
                    scene.remove(orbitLine);
                    if (orbitLine.geometry) orbitLine.geometry.dispose();
                    if (orbitLine.material) orbitLine.material.dispose();
                } catch (e) {
                    console.warn('ç§»é™¤è½¨é“çº¿æ—¶å‡ºé”™:', e);
                }
                
                orbitLine = null;
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰é€Ÿåº¦æ•°æ®
            console.log('æ£€æŸ¥è½¨é“æ•°æ®:', {
                pmra: star.pmra,
                pmdec: star.pmdec,
                radial_velocity: star.radial_velocity,
                ra: star.ra,
                dec: star.dec
            });
            
            // ä½¿ç”¨æ›´ä¸¥æ ¼çš„æ£€æŸ¥ï¼šæ£€æŸ¥å­—æ®µæ˜¯å¦å­˜åœ¨ä¸”ä¸ä¸ºnull/undefinedï¼ˆå…è®¸0å€¼ï¼‰
            const hasPmra = star.pmra !== null && star.pmra !== undefined;
            const hasPmdec = star.pmdec !== null && star.pmdec !== undefined;
            const hasRadialVelocity = star.radial_velocity !== null && star.radial_velocity !== undefined;
            
            if (!hasPmra && !hasPmdec && !hasRadialVelocity) {
                console.log('æ’æ˜Ÿæ²¡æœ‰é€Ÿåº¦æ•°æ®ï¼Œæ— æ³•è®¡ç®—è½¨é“');
                return;
            }

            // è®¡ç®—é€Ÿåº¦å‘é‡
            const velocity = calculateStarVelocity(star, starPos);
            console.log('è®¡ç®—çš„é€Ÿåº¦å‘é‡:', velocity);
            
            if (velocity.vx === 0 && velocity.vy === 0 && velocity.vz === 0) {
                console.log('æ’æ˜Ÿé€Ÿåº¦ä¸ºé›¶ï¼Œæ— æ³•è®¡ç®—è½¨é“');
                return;
            }

            // è®¡ç®—è½¨é“æ—¶é—´èŒƒå›´ï¼ˆå•ä½ï¼šå¹´ï¼‰
            // æ ¹æ®é€Ÿåº¦å¤§å°å’Œè·ç¦»ï¼Œè®¡ç®—åˆé€‚çš„æ—¶é—´èŒƒå›´
            const speed = Math.sqrt(velocity.vx * velocity.vx + velocity.vy * velocity.vy + velocity.vz * velocity.vz);
            const distance = starPos.distance || Math.sqrt(starPos.x * starPos.x + starPos.y * starPos.y + starPos.z * starPos.z);
            
            // æ—¶é—´èŒƒå›´ï¼šè®©è½¨é“é•¿åº¦çº¦ä¸ºå½“å‰è·ç¦»çš„2-3å€
            const timeRange = distance > 0 ? Math.min(Math.max(distance / speed * 2, 10000), 1000000) : 100000;
            const timeSteps = 200; // è½¨é“ç‚¹æ•°
            const dt = timeRange / timeSteps;

            // ç”Ÿæˆè½¨é“ç‚¹
            const orbitPoints = [];
            for (let i = -timeSteps / 2; i <= timeSteps / 2; i++) {
                const t = i * dt; // æ—¶é—´ï¼ˆå¹´ï¼‰
                
                // è®¡ç®—æœªæ¥/è¿‡å»çš„ä½ç½®
                const x = starPos.x + velocity.vx * t;
                const y = starPos.y + velocity.vy * t;
                const z = starPos.z + velocity.vz * t;
                
                orbitPoints.push(new THREE.Vector3(x, y, z));
            }

            // åˆ›å»ºè½¨é“çº¿ï¼ˆä½¿ç”¨çº¯è‰²çº¿æ¡ï¼‰
            const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
            const orbitMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffff, // é’è‰²
                linewidth: 2, // æ³¨æ„ï¼šWebGLä¸­linewidthå¯èƒ½ä¸èµ·ä½œç”¨ï¼Œä½†ä¿ç•™è®¾ç½®
                transparent: true,
                opacity: 0.9,
                depthTest: true,
                depthWrite: false // é¿å…æ·±åº¦å†²çª
            });
            
            // åˆ›å»ºè½¨é“çº¿
            orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
            orbitLine.renderOrder = 1000; // ç¡®ä¿è½¨é“çº¿åœ¨å…¶ä»–ç‰©ä½“ä¹‹ä¸Šæ¸²æŸ“
            orbitLine.name = 'starOrbit'; // æ·»åŠ åç§°ä¾¿äºè°ƒè¯•
            scene.add(orbitLine);

            // è®¡ç®—è½¨é“çº¿çš„è¾¹ç•Œæ¡†ï¼Œç”¨äºè°ƒè¯•
            orbitGeometry.computeBoundingBox();
            const bbox = orbitGeometry.boundingBox;
            
            console.log(`å·²ç»˜åˆ¶è½¨é“: æ—¶é—´èŒƒå›´ Â±${(timeRange / 2 / 1000).toFixed(1)}åƒå¹´, é€Ÿåº¦ ${(speed * 1000).toFixed(2)} å•ä½/åƒå¹´`);
            console.log(`è½¨é“ç‚¹æ•°: ${orbitPoints.length}, èµ·å§‹ä½ç½®: (${orbitPoints[0].x.toFixed(2)}, ${orbitPoints[0].y.toFixed(2)}, ${orbitPoints[0].z.toFixed(2)})`);
            console.log(`å½“å‰æ’æ˜Ÿä½ç½®: (${starPos.x.toFixed(2)}, ${starPos.y.toFixed(2)}, ${starPos.z.toFixed(2)})`);
            console.log(`é€Ÿåº¦å‘é‡: (${velocity.vx.toFixed(6)}, ${velocity.vy.toFixed(6)}, ${velocity.vz.toFixed(6)})`);
            console.log(`è½¨é“çº¿è¾¹ç•Œæ¡†:`, bbox ? {
                min: `(${bbox.min.x.toFixed(2)}, ${bbox.min.y.toFixed(2)}, ${bbox.min.z.toFixed(2)})`,
                max: `(${bbox.max.x.toFixed(2)}, ${bbox.max.y.toFixed(2)}, ${bbox.max.z.toFixed(2)})`
            } : 'æ— ');
            console.log(`è½¨é“çº¿å·²æ·»åŠ åˆ°åœºæ™¯ï¼Œåœºæ™¯ä¸­çš„å¯¹è±¡æ•°é‡: ${scene.children.length}`);
        }

        function getStarColor(colorIndex) {
            if (colorIndex === null || colorIndex === undefined) {
                return new THREE.Color(0xffffff);
            }

            let r, g, b;

            if (colorIndex < -0.5) {
                r = 0.3;
                g = 0.5;
                b = 1.0;
            } else if (colorIndex < 0.5) {
                const t = (colorIndex + 0.5) / 1.0;
                r = 0.7 + 0.3 * t;
                g = 0.8 + 0.2 * t;
                b = 1.0;
            } else if (colorIndex < 1.5) {
                const t = (colorIndex - 0.5) / 1.0;
                r = 1.0;
                g = 1.0 - 0.2 * t;
                b = 1.0 - 0.5 * t;
            } else {
                const t = Math.min((colorIndex - 1.5) / 2.0, 1.0);
                r = 1.0;
                g = 0.8 - 0.5 * t;
                b = 0.5 - 0.5 * t;
            }

            return new THREE.Color(r, g, b);
        }

        // å°†ä¸åŒæ¥æº/å­—æ®µåçš„æ’æ˜Ÿå¯¹è±¡è§„èŒƒä¸ºç»Ÿä¸€ç»“æ„
        function normalizeStarsObjectArray(stars) {
            // ç»Ÿä¸€è¾“å‡ºå­—æ®µï¼š
            // source_id, ra, dec, parallax, pmra, pmdec, radial_velocity, l, b, magnitude, color_index
            const toNumber = (v, fb = null) => {
                if (v === null || v === undefined) return fb;
                const n = typeof v === 'string' ? parseFloat(v) : v;
                return Number.isFinite(n) ? n : fb;
            };
            return stars.map(s => {
                // å¦‚æœæ˜¯ col_0/col_1... è¿™ç§é”®ï¼ŒæŒ‰æ—¢å®šåˆ—é¡ºåºæ˜ å°„
                const isColForm = s && typeof s === 'object' && ('col_0' in s || 'col_1' in s);
                if (isColForm) {
                    const source_id_val = s.col_0;
                    const source_id = source_id_val !== null && source_id_val !== undefined ? String(source_id_val) : null;
                    const ra = toNumber(s.col_1, null);
                    const dec = toNumber(s.col_2, null);
                    const parallax = toNumber(s.col_3, null);
                    const pmra = toNumber(s.col_5, null);
                    const pmdec = toNumber(s.col_7, null);
                    const magnitudeRaw = toNumber(s.col_9, 15);
                    const colorIndexRaw = toNumber(s.col_12, undefined);
                    const bpMag = toNumber(s.col_18, undefined);
                    const rpMag = toNumber(s.col_19, undefined);
                    const bp_g = toNumber(s.col_13, undefined);
                    let color_index = colorIndexRaw;
                    if (color_index === undefined || color_index === null) {
                        if (bpMag !== undefined && rpMag !== undefined) color_index = toNumber(bpMag - rpMag, 0.5);
                        else if (bp_g !== undefined) color_index = toNumber(bp_g, 0.5);
                        else color_index = 0.5;
                    }
                    let magnitude = magnitudeRaw;
                    if (!Number.isFinite(magnitude)) magnitude = 15;
                    if (!Number.isFinite(color_index)) color_index = 0.5;
                    const radial_velocity = toNumber(s.col_14, null);
                    const l = toNumber(s.col_20, null);
                    const b = toNumber(s.col_21, null);
                    return {
                        source_id,
                        ra,
                        dec,
                        parallax,
                        pmra,
                        pmdec,
                        radial_velocity,
                        l,
                        b,
                        magnitude,
                        color_index
                    };
                }
                // å…è®¸è¾“å…¥å¯¹è±¡å·²æ˜¯è§„èŒƒå­—æ®µæˆ–æ˜¯ Gaia åŸå§‹å‘½å
                const raw_source_id = s.source_id ?? s.id ?? s.sourceId ?? null;
                // ä»¥å­—ç¬¦ä¸²å­˜å‚¨ï¼Œé¿å…JSå®‰å…¨æ•´æ•°é—®é¢˜ï¼ŒåŒæ—¶ç¡®ä¿åœ¨åˆ—è¡¨ä¸­å¯è§
                const source_id = raw_source_id !== null && raw_source_id !== undefined ? String(raw_source_id) : null;
                const ra = toNumber(s.ra ?? s.right_ascension, null);
                const dec = toNumber(s.dec ?? s.declination, null);
                const parallax = toNumber(s.parallax ?? s.plx, null);
                const pmra = toNumber(s.pmra ?? s.pm_ra ?? s.proper_motion_ra, null);
                const pmdec = toNumber(s.pmdec ?? s.pm_dec ?? s.proper_motion_dec, null);
                const radial_velocity = toNumber(s.radial_velocity ?? s.vrad ?? s.rv, null);
                const l = toNumber(s.l ?? s.gal_l ?? s.lon, null);
                const b = toNumber(s.b ?? s.gal_b ?? s.lat, null);
                // äº®åº¦ä¼˜å…ˆçº§ï¼šmagnitude -> phot_g_mean_mag -> phot_bp_mean_mag
                let magnitude = toNumber(s.magnitude ?? s.phot_g_mean_mag ?? s.phot_bp_mean_mag, 15);
                // è‰²æŒ‡æ•°ä¼˜å…ˆçº§ï¼šcolor_index -> bp_rp -> (phot_bp_mean_mag - phot_rp_mean_mag) -> bp_g
                let color_index = toNumber(s.color_index ?? s.bp_rp, undefined);
                if (color_index === undefined || color_index === null) {
                    const bp = toNumber(s.phot_bp_mean_mag, undefined);
                    const rp = toNumber(s.phot_rp_mean_mag, undefined);
                    const bpg = toNumber(s.bp_g, undefined);
                    if (bp !== undefined && rp !== undefined) color_index = toNumber(bp - rp, 0.5);
                    else if (bpg !== undefined) color_index = toNumber(bpg, 0.5);
                    else color_index = 0.5;
                }
                // å…œåº•ï¼šè‹¥magnitudeä¸æ˜¯æœ‰æ•ˆæ•°ï¼Œåˆ™ç”¨15ï¼›color_indexè‹¥æ— æ•ˆåˆ™ç”¨0.5
                if (!Number.isFinite(magnitude)) magnitude = 15;
                if (!Number.isFinite(color_index)) color_index = 0.5;
                return {
                    source_id,
                    ra,
                    dec,
                    parallax,
                    pmra,
                    pmdec,
                    radial_velocity,
                    l,
                    b,
                    magnitude,
                    color_index
                };
            });
        }

        function getStarSize(magnitude) {
            const baseSize = 0.5;
            const maxSize = 3.0;
            const size = baseSize + (15 - magnitude) * 0.2;
            return Math.min(Math.max(size, 0.1), maxSize) * 0.01;
        }

        function updateStarUniforms() {
            if (glowMaterial && glowMaterial.uniforms) {
                glowMaterial.uniforms.uBrightness.value = brightness;
                glowMaterial.uniforms.uStarSize.value = starSize;
            }
            if (solidMaterial && solidMaterial.uniforms) {
                solidMaterial.uniforms.uBrightness.value = brightness;
                solidMaterial.uniforms.uStarSize.value = starSize;
            }
        }

        function createStars(data) {
            const savedControlsState = controls ? controls.getState() : null;
            
            if (glowPoints) {
                scene.remove(glowPoints);
                glowGeometry.dispose();
                glowMaterial.dispose();
            }
            if (solidPoints) {
                scene.remove(solidPoints);
                solidGeometry.dispose();
                solidMaterial.dispose();
            }

            const maxLimit = 1000000;
            const limit = Math.min(data.length, currentLimit, maxLimit);
            const glowPositions = new Float32Array(limit * 3);
            const glowColors = new Float32Array(limit * 3);
            const glowSizes = new Float32Array(limit);
            
            const solidPositions = new Float32Array(limit * 3);
            const solidColors = new Float32Array(limit * 3);
            const solidSizes = new Float32Array(limit);

            const batchSize = 10000;
            for (let batchStart = 0; batchStart < limit; batchStart += batchSize) {
                const batchEnd = Math.min(batchStart + batchSize, limit);
                for (let i = batchStart; i < batchEnd; i++) {
                const star = data[i];
                const pos = convertTo3D(star.ra, star.dec, star.parallax, star.l, star.b);
                const color = getStarColor(star.color_index);
                const size = getStarSize(star.magnitude);
                glowPositions[i * 3] = pos.x;
                glowPositions[i * 3 + 1] = pos.y;
                glowPositions[i * 3 + 2] = pos.z;
                glowColors[i * 3] = color.r;
                glowColors[i * 3 + 1] = color.g;
                glowColors[i * 3 + 2] = color.b;
                glowSizes[i] = size * 1.5;
                
                solidPositions[i * 3] = pos.x;
                solidPositions[i * 3 + 1] = pos.y;
                solidPositions[i * 3 + 2] = pos.z;
                solidColors[i * 3] = color.r;
                solidColors[i * 3 + 1] = color.g;
                solidColors[i * 3 + 2] = color.b;
                solidSizes[i] = size * 0.6;
                }
            }
            
            // åˆ›å»ºå‘å…‰ç‚¹
            glowGeometry = new THREE.BufferGeometry();
            glowGeometry.setAttribute('position', new THREE.BufferAttribute(glowPositions, 3));
            glowGeometry.setAttribute('color', new THREE.BufferAttribute(glowColors, 3));
            glowGeometry.setAttribute('size', new THREE.BufferAttribute(glowSizes, 1));
            
            glowGeometry.getAttribute('position').needsUpdate = false;
            glowGeometry.getAttribute('color').needsUpdate = false;
            glowGeometry.getAttribute('size').needsUpdate = false;

            const glowVertexShader = `
                precision highp float;  // ä½¿ç”¨é«˜ç²¾åº¦æµ®ç‚¹æ•°
                precision highp int;
                attribute vec3 position;
                attribute float size;
                attribute vec3 color;
                uniform mat4 modelViewMatrix;
                uniform mat4 projectionMatrix;
                uniform float uBrightness; // äº®åº¦uniform
                uniform float uStarSize;   // å¤§å°uniform
                uniform highp float uScale; // é«˜ç²¾åº¦ç³»æ•°ï¼ˆ10äº¿ï¼‰
                varying vec3 vColor;
                varying highp float vDepth;
                varying highp float vPointSize;
                varying highp float vDepthRaw;
                void main() {
                    vColor = color * uBrightness;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    float finalSize = size * uStarSize;
                    
                    // é«˜ç²¾åº¦æ·±åº¦è®¡ç®—ï¼šä½¿ç”¨SCALEç³»æ•°å¤„ç†æå°çš„æ·±åº¦å€¼
                    // æ³¨æ„ï¼šmvPosition.zåœ¨ç›¸æœºåæ ‡ç³»ä¸­ï¼Œè´Ÿå€¼è¡¨ç¤ºç‚¹åœ¨ç›¸æœºå‰æ–¹ï¼Œæ­£å€¼è¡¨ç¤ºåœ¨åæ–¹
                    // ä½¿ç”¨ç»å¯¹å€¼è®¡ç®—æ·±åº¦ï¼Œä½†ä¿ç•™ç¬¦å·ä¿¡æ¯ç”¨äºåˆ¤æ–­æ–¹å‘
                    highp float depthRaw = mvPosition.z;
                    vDepthRaw = depthRaw; // ä¼ é€’åŸå§‹æ·±åº¦ï¼ˆå¸¦ç¬¦å·ï¼‰
                    highp float depth = abs(depthRaw); // æ·±åº¦è·ç¦»ï¼ˆæ€»æ˜¯æ­£æ•°ï¼‰
                    highp float depthScaled = depth * uScale; // æ·±åº¦å€¼ä¹˜ä»¥SCALE
                    
                    // ä½¿ç”¨æå°çš„æœ€å°å€¼ï¼ˆä¹Ÿä¹˜ä»¥SCALEï¼‰ï¼Œä½†ç¡®ä¿æ•°å€¼ç¨³å®š
                    // å…è®¸æ·±åº¦å¯ä»¥éå¸¸å°ï¼Œè®©ç‚¹å¯ä»¥æŒç»­æ”¾å¤§
                    highp float minDepthScaled = max(depthScaled, 1.0); // æœ€å°æ·±åº¦ä¸º1ï¼ˆç›¸å½“äº1/SCALEï¼‰
                    highp float minDepth = minDepthScaled / uScale; // è½¬æ¢å›çœŸå®æ·±åº¦
                    
                    // ç‚¹å¤§å°è®¡ç®—ï¼šä½¿ç”¨ç¼©æ”¾åçš„æ·±åº¦å€¼ä¿æŒç²¾åº¦
                    // è®©ç‚¹åœ¨æ¥è¿‘æ—¶æŒç»­æ”¾å¤§ï¼Œç©¿è¿‡æ—¶æ­£å¸¸è¿‡æ¸¡
                    highp float pointSize = finalSize * (300.0 / minDepth);
                    vPointSize = pointSize; // ä¼ é€’ç‚¹å¤§å°åˆ°fragment shader
                    
                    // é™åˆ¶ç‚¹å¤§å°ï¼Œä½†å…è®¸è¾ƒå¤§çš„å€¼ä»¥ä¾¿ç‚¹å¯ä»¥æ­£å¸¸æ”¾å¤§
                    // å½“ç‚¹åœ¨ç›¸æœºåæ–¹æ—¶ï¼Œæ·±åº¦ä¼šå¢å¤§ï¼Œç‚¹ä¼šè‡ªç„¶ç¼©å°
                    gl_PointSize = clamp(pointSize, 1.0, 2048.0);
                    gl_Position = projectionMatrix * mvPosition;
                    vDepth = depth;
                }
            `;

            const glowFragmentShader = `
                precision highp float;  // ä½¿ç”¨é«˜ç²¾åº¦æµ®ç‚¹æ•°
                precision highp int;
                varying vec3 vColor;
                varying highp float vDepth;
                varying highp float vPointSize;
                varying highp float vDepthRaw;
                uniform highp float uScale; // é«˜ç²¾åº¦ç³»æ•°ï¼ˆ10äº¿ï¼‰
                
                void main() {
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    highp float dist = length(coord);
                    highp float radius = 0.5;
                    
                    // è®¡ç®—çƒä½“æ·±åº¦ï¼šæ ¹æ®ç‚¹åˆ°ä¸­å¿ƒçš„è·ç¦»è®¡ç®—æ·±åº¦
                    // å¯¹äºä¸€ä¸ªçƒä½“ï¼Œä¸­å¿ƒæ·±åº¦æœ€æ·±ï¼Œè¾¹ç¼˜æ·±åº¦è¾ƒæµ…
                    // æ”¯æŒçƒä½“éƒ¨åˆ†åœ¨ç›¸æœºå‰æ–¹ï¼Œéƒ¨åˆ†åœ¨ç›¸æœºåæ–¹çš„æƒ…å†µ
                    
                    // è®¡ç®—çƒä½“åœ¨è§†å›¾ç©ºé—´ä¸­çš„åŠå¾„
                    // ç‚¹å¤§å°vPointSizeæ˜¯å±å¹•ç©ºé—´ä¸­çš„åƒç´ å¤§å°
                    // è§†å›¾ç©ºé—´åŠå¾„ = å±å¹•ç©ºé—´åŠå¾„ * è§†å›¾ç©ºé—´æ·±åº¦ / æŠ•å½±ç³»æ•°
                    // æŠ•å½±ç³»æ•°çº¦ä¸º300.0ï¼ˆä»ç‚¹å¤§å°è®¡ç®—å…¬å¼ä¸­å¾—å‡ºï¼‰
                    highp float viewDepth = abs(vDepthRaw);
                    highp float viewRadius = (vPointSize * 0.5) * viewDepth / 300.0;
                    
                    // å°†å±å¹•ç©ºé—´è·ç¦»è½¬æ¢ä¸ºè§†å›¾ç©ºé—´è·ç¦»
                    highp float viewDist = dist * viewRadius * 2.0; // distæ˜¯å½’ä¸€åŒ–çš„ï¼Œéœ€è¦ä¹˜ä»¥åŠå¾„çš„2å€
                    
                    // è®¡ç®—çƒä½“è¡¨é¢ç›¸å¯¹äºçƒå¿ƒçš„æ·±åº¦åç§»
                    // ä½¿ç”¨çƒä½“æ–¹ç¨‹ï¼šz_offset = sqrt(r^2 - d^2)
                    // å…¶ä¸­ræ˜¯è§†å›¾ç©ºé—´åŠå¾„ï¼Œdæ˜¯è§†å›¾ç©ºé—´ä¸­åˆ°ä¸­å¿ƒçš„è·ç¦»
                    highp float sphereDepthOffset = sqrt(max(viewRadius * viewRadius - viewDist * viewDist, 0.0));
                    
                    // è®¡ç®—çƒä½“è¡¨é¢çš„è§†å›¾ç©ºé—´æ·±åº¦
                    // çƒå¿ƒåœ¨vDepthRawï¼Œçƒä½“è¡¨é¢åœ¨çƒå¿ƒæ²¿zè½´æ–¹å‘åç§»sphereDepthOffset
                    // å¯¹äºçƒä½“è¡¨é¢çš„æ¯ä¸ªç‚¹ï¼Œæ·±åº¦ = çƒå¿ƒæ·±åº¦ Â± æ·±åº¦åç§»
                    // æœå‘ç›¸æœºçš„éƒ¨åˆ†ï¼ˆæ›´æ¥è¿‘ç›¸æœºï¼‰ï¼šæ·±åº¦åç§»ä¸ºæ­£
                    // è¿œç¦»ç›¸æœºçš„éƒ¨åˆ†ï¼ˆæ›´è¿œç¦»ç›¸æœºï¼‰ï¼šæ·±åº¦åç§»ä¸ºè´Ÿ
                    // è¿™æ ·å¯ä»¥è®©çƒä½“éƒ¨åˆ†åœ¨ç›¸æœºå‰æ–¹ï¼Œéƒ¨åˆ†åœ¨ç›¸æœºåæ–¹
                    highp float finalViewDepth;
                    
                    // è®¡ç®—çƒä½“è¡¨é¢æœå‘ç›¸æœºçš„æ·±åº¦ï¼ˆæ›´æ¥è¿‘ç›¸æœºï¼‰
                    // å¦‚æœçƒå¿ƒåœ¨ç›¸æœºå‰æ–¹ï¼ˆvDepthRaw < 0ï¼‰ï¼Œæœå‘ç›¸æœºçš„è¡¨é¢æ·±åº¦ = vDepthRaw + sphereDepthOffset
                    // å¦‚æœçƒå¿ƒåœ¨ç›¸æœºåæ–¹ï¼ˆvDepthRaw > 0ï¼‰ï¼Œæœå‘ç›¸æœºçš„è¡¨é¢æ·±åº¦ = vDepthRaw - sphereDepthOffset
                    // ä½†ä¸ºäº†æ”¯æŒçƒä½“éƒ¨åˆ†åœ¨ç›¸æœºå‰æ–¹ï¼Œæˆ‘ä»¬æ€»æ˜¯ä½¿ç”¨æœå‘ç›¸æœºçš„è¡¨é¢æ·±åº¦
                    if (vDepthRaw < 0.0) {
                        // çƒå¿ƒåœ¨ç›¸æœºå‰æ–¹ï¼Œæœå‘ç›¸æœºçš„è¡¨é¢æ›´æ¥è¿‘ç›¸æœºï¼ˆæ·±åº¦å€¼æ›´è´Ÿï¼Œç»å¯¹å€¼æ›´å°ï¼‰
                        finalViewDepth = vDepthRaw + sphereDepthOffset;
                    } else {
                        // çƒå¿ƒåœ¨ç›¸æœºåæ–¹ï¼Œæœå‘ç›¸æœºçš„è¡¨é¢æ›´æ¥è¿‘ç›¸æœºï¼ˆæ·±åº¦å€¼æ›´è´Ÿï¼Œå¯èƒ½å˜ä¸ºè´Ÿæ•°ï¼‰
                        finalViewDepth = vDepthRaw - sphereDepthOffset;
                    }
                    
                    // å…è®¸çƒä½“éƒ¨åˆ†åœ¨ç›¸æœºå‰æ–¹ï¼Œéƒ¨åˆ†åœ¨ç›¸æœºåæ–¹
                    // finalViewDepthå¯ä»¥æ˜¯è´Ÿæ•°ï¼ˆç›¸æœºå‰æ–¹ï¼‰æˆ–æ­£æ•°ï¼ˆç›¸æœºåæ–¹ï¼‰
                    
                    // å°†è§†å›¾ç©ºé—´æ·±åº¦è½¬æ¢ä¸ºNDCæ·±åº¦ï¼ˆå½’ä¸€åŒ–è®¾å¤‡åæ ‡ï¼‰
                    // é€è§†æŠ•å½±å…¬å¼ï¼šndc_z = (far + near) / (far - near) - (2.0 * far * near) / ((far - near) * view_z)
                    // å¯¹äºThree.jsï¼Œview_zé€šå¸¸æ˜¯è´Ÿæ•°ï¼ˆç›¸æœºçœ‹å‘-zæ–¹å‘ï¼‰
                    highp float near = 0.000000001;
                    highp float far = 100000.0;
                    
                    // å¤„ç†view_zçš„ç¬¦å·ï¼šæ”¯æŒç‚¹åœ¨ç›¸æœºå‰æ–¹å’Œåæ–¹
                    highp float viewZ = finalViewDepth;
                    
                    
                    highp float alpha = 1.0 - smoothstep(0.0, radius, dist);
                    highp float glow = 1.0 + (1.0 - dist * 2.0) * 0.5;
                    vec3 finalColor = vColor * glow;
                    gl_FragColor = vec4(finalColor, alpha * 0.6);
                }
            `;

            glowMaterial = new THREE.RawShaderMaterial({
                vertexShader: glowVertexShader,
                fragmentShader: glowFragmentShader,
                vertexColors: true,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,  // æš‚æ—¶ç¦ç”¨æ·±åº¦å†™å…¥ï¼Œä½¿ç”¨é»˜è®¤æ·±åº¦
                depthTest: true,
                uniforms: {
                    uBrightness: { value: brightness },
                    uStarSize: { value: starSize },
                    uScale: { value: HighPrecisionMath.SCALE_F } // ä¼ é€’é«˜ç²¾åº¦ç³»æ•°
                }
            });

            glowPoints = new THREE.Points(glowGeometry, glowMaterial);
            scene.add(glowPoints);

            // åˆ›å»ºå®å¿ƒç‚¹
            solidGeometry = new THREE.BufferGeometry();
            solidGeometry.setAttribute('position', new THREE.BufferAttribute(solidPositions, 3));
            solidGeometry.setAttribute('color', new THREE.BufferAttribute(solidColors, 3));
            solidGeometry.setAttribute('size', new THREE.BufferAttribute(solidSizes, 1));
            
            solidGeometry.getAttribute('position').needsUpdate = false;
            solidGeometry.getAttribute('color').needsUpdate = false;
            solidGeometry.getAttribute('size').needsUpdate = false;

            const solidVertexShader = `
                precision highp float;  // ä½¿ç”¨é«˜ç²¾åº¦æµ®ç‚¹æ•°
                precision highp int;
                attribute vec3 position;
                attribute float size;
                attribute vec3 color;
                uniform mat4 modelViewMatrix;
                uniform mat4 projectionMatrix;
                uniform float uBrightness; // äº®åº¦uniform
                uniform float uStarSize;   // å¤§å°uniform
                uniform highp float uScale; // é«˜ç²¾åº¦ç³»æ•°ï¼ˆ10äº¿ï¼‰
                varying vec3 vColor;
                varying highp float vPointSize;
                varying highp float vDepthRaw;
                void main() {
                    vColor = color * uBrightness;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    float finalSize = size * uStarSize;
                    
                    // é«˜ç²¾åº¦æ·±åº¦è®¡ç®—ï¼šä½¿ç”¨SCALEç³»æ•°å¤„ç†æå°çš„æ·±åº¦å€¼
                    // æ³¨æ„ï¼šmvPosition.zåœ¨ç›¸æœºåæ ‡ç³»ä¸­ï¼Œè´Ÿå€¼è¡¨ç¤ºç‚¹åœ¨ç›¸æœºå‰æ–¹ï¼Œæ­£å€¼è¡¨ç¤ºåœ¨åæ–¹
                    // ä½¿ç”¨ç»å¯¹å€¼è®¡ç®—æ·±åº¦ï¼Œä½†ä¿ç•™ç¬¦å·ä¿¡æ¯ç”¨äºåˆ¤æ–­æ–¹å‘
                    highp float depthRaw = mvPosition.z;
                    vDepthRaw = depthRaw; // ä¼ é€’åŸå§‹æ·±åº¦ï¼ˆå¸¦ç¬¦å·ï¼‰
                    highp float depth = abs(depthRaw); // æ·±åº¦è·ç¦»ï¼ˆæ€»æ˜¯æ­£æ•°ï¼‰
                    highp float depthScaled = depth * uScale; // æ·±åº¦å€¼ä¹˜ä»¥SCALE
                    
                    // ä½¿ç”¨æå°çš„æœ€å°å€¼ï¼ˆä¹Ÿä¹˜ä»¥SCALEï¼‰ï¼Œä½†ç¡®ä¿æ•°å€¼ç¨³å®š
                    // å…è®¸æ·±åº¦å¯ä»¥éå¸¸å°ï¼Œè®©ç‚¹å¯ä»¥æŒç»­æ”¾å¤§
                    highp float minDepthScaled = max(depthScaled, 1.0); // æœ€å°æ·±åº¦ä¸º1ï¼ˆç›¸å½“äº1/SCALEï¼‰
                    highp float minDepth = minDepthScaled / uScale; // è½¬æ¢å›çœŸå®æ·±åº¦
                    
                    // ç‚¹å¤§å°è®¡ç®—ï¼šä½¿ç”¨ç¼©æ”¾åçš„æ·±åº¦å€¼ä¿æŒç²¾åº¦
                    // è®©ç‚¹åœ¨æ¥è¿‘æ—¶æŒç»­æ”¾å¤§ï¼Œç©¿è¿‡æ—¶æ­£å¸¸è¿‡æ¸¡
                    highp float pointSize = finalSize * (300.0 / minDepth);
                    vPointSize = pointSize; // ä¼ é€’ç‚¹å¤§å°åˆ°fragment shader
                    
                    // é™åˆ¶ç‚¹å¤§å°ï¼Œä½†å…è®¸è¾ƒå¤§çš„å€¼ä»¥ä¾¿ç‚¹å¯ä»¥æ­£å¸¸æ”¾å¤§
                    // å½“ç‚¹åœ¨ç›¸æœºåæ–¹æ—¶ï¼Œæ·±åº¦ä¼šå¢å¤§ï¼Œç‚¹ä¼šè‡ªç„¶ç¼©å°
                    gl_PointSize = clamp(pointSize, 1.0, 2048.0);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `;

            const solidFragmentShader = `
                precision highp float;  // ä½¿ç”¨é«˜ç²¾åº¦æµ®ç‚¹æ•°
                precision highp int;
                varying vec3 vColor;
                varying highp float vPointSize;
                varying highp float vDepthRaw;
                uniform highp float uScale; // é«˜ç²¾åº¦ç³»æ•°ï¼ˆ10äº¿ï¼‰
                
                void main() {
                    vec2 coord = gl_PointCoord - vec2(0.5);
                    highp float dist = length(coord);
                    highp float solidRadius = 0.48;
                    if (dist > solidRadius) {
                        discard;
                    }
                    
                    highp float viewDepth = abs(vDepthRaw);
                    highp float viewRadius = (vPointSize * 0.5) * viewDepth / 300.0;
                    highp float viewDist = dist * viewRadius * 2.0;
                    
                    highp float sphereDepthOffset = sqrt(max(viewRadius * viewRadius - viewDist * viewDist, 0.0));
                    
                    highp float finalViewDepth;
                    if (vDepthRaw < 0.0) {
                        finalViewDepth = vDepthRaw + sphereDepthOffset;
                    } else {
                        finalViewDepth = vDepthRaw - sphereDepthOffset;
                    }
                    
                    highp float near = 0.000000001;
                    highp float far = 100000.0;
                    highp float viewZ = finalViewDepth;
                    
                    gl_FragColor = vec4(vColor, 1.0);
                }
            `;

            solidMaterial = new THREE.RawShaderMaterial({
                vertexShader: solidVertexShader,
                fragmentShader: solidFragmentShader,
                vertexColors: true,
                transparent: false,
                blending: THREE.NormalBlending,
                depthWrite: true,
                depthTest: true,
                uniforms: {
                    uBrightness: { value: brightness },
                    uStarSize: { value: starSize },
                    uScale: { value: HighPrecisionMath.SCALE_F }
                }
            });

            solidPoints = new THREE.Points(solidGeometry, solidMaterial);
            scene.add(solidPoints);
            
            if (savedControlsState && controls) {
                controls.setState(savedControlsState);
                controls.update();
            }
        }

        async function handleFileUpload(file) {
            const uploadPanel = document.getElementById('upload-panel');
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loading-text');
            const uploadError = document.getElementById('upload-error');
            const fileName = document.getElementById('file-name');
            
            uploadError.style.display = 'none';
            if (!file.name.toLowerCase().endsWith('.json')) {
                uploadError.textContent = 'é”™è¯¯: è¯·ä¸Šä¼ JSONæ ¼å¼çš„æ–‡ä»¶';
                uploadError.style.display = 'block';
                return;
            }
            
            const fileSizeMB = file.size / 1024 / 1024;
            if (fileSizeMB > 500) {
                uploadError.textContent = `è­¦å‘Š: æ–‡ä»¶è¾ƒå¤§ (${fileSizeMB.toFixed(2)} MB)ï¼Œè¯»å–å¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´`;
                uploadError.style.display = 'block';
            }
            
            fileName.textContent = `å·²é€‰æ‹©: ${file.name} (${fileSizeMB.toFixed(2)} MB)`;
            uploadPanel.style.display = 'none';
            loading.style.display = 'block';
            loadingText.textContent = `æ­£åœ¨è¯»å–æ–‡ä»¶... (${fileSizeMB.toFixed(2)} MB)`;
            
            try {
                const fileContent = await readFileAsText(file);
                
                const expectedSize = file.size;
                const actualSize = new Blob([fileContent]).size;
                const sizeDiff = Math.abs(expectedSize - actualSize);
                const sizeDiffPercent = (sizeDiff / expectedSize) * 100;
                
                if (sizeDiffPercent > 1 || sizeDiff > 1024 * 1024) {
                    console.warn(`æ–‡ä»¶å¤§å°ä¸åŒ¹é…: é¢„æœŸ ${(expectedSize / 1024 / 1024).toFixed(2)} MB, ` +
                        `å®é™…è¯»å– ${(actualSize / 1024 / 1024).toFixed(2)} MB, ` +
                        `å·®å¼‚ ${(sizeDiff / 1024 / 1024).toFixed(2)} MB (${sizeDiffPercent.toFixed(2)}%)`);
                }
                
                const trimmedContent = fileContent.trim();
                if (trimmedContent.length === 0) {
                    throw new Error('æ–‡ä»¶å†…å®¹ä¸ºç©º');
                }
                
                if (!trimmedContent.startsWith('{') && !trimmedContent.startsWith('[')) {
                    throw new Error('æ–‡ä»¶æ ¼å¼é”™è¯¯: JSONæ–‡ä»¶åº”ä»¥ { æˆ– [ å¼€å¤´');
                }
                
                if (!trimmedContent.endsWith('}') && !trimmedContent.endsWith(']')) {
                    const fileSizeMB = (file.size / 1024 / 1024).toFixed(2);
                    const contentSizeMB = (fileContent.length / 1024 / 1024).toFixed(2);
                    const sizeDiff = Math.abs(file.size - fileContent.length);
                    const sizeDiffMB = (sizeDiff / 1024 / 1024).toFixed(2);
                    
                    let errorMsg = 'æ–‡ä»¶å¯èƒ½ä¸å®Œæ•´: JSONæ–‡ä»¶åº”ä»¥ } æˆ– ] ç»“å°¾ã€‚';
                    errorMsg += `æ–‡ä»¶å¤§å°: ${fileSizeMB} MBï¼Œè¯»å–é•¿åº¦: ${contentSizeMB} MB`;
                    if (sizeDiff > 1024) { // å¦‚æœå·®å¼‚è¶…è¿‡1KB
                        errorMsg += `ï¼Œå·®å¼‚: ${sizeDiffMB} MBï¼ˆæ–‡ä»¶å¯èƒ½æœªå®Œå…¨è¯»å–ï¼‰`;
                    }
                    throw new Error(errorMsg);
                }
                
                loadingText.textContent = 'æ­£åœ¨è§£ææ•°æ®...';
                let data;
                try {
                    data = JSON.parse(fileContent);
                } catch (parseError) {
                    // æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                    if (parseError.message.includes('Unexpected end of JSON input')) {
                        throw new Error('JSONè§£æé”™è¯¯: æ–‡ä»¶å¯èƒ½ä¸å®Œæ•´æˆ–è¢«æˆªæ–­ã€‚æ–‡ä»¶å¤§å°: ' + 
                            (file.size / 1024 / 1024).toFixed(2) + ' MBï¼Œè¯»å–é•¿åº¦: ' + 
                            (fileContent.length / 1024 / 1024).toFixed(2) + ' MBã€‚' +
                            'è¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å®Œæ•´ä¸Šä¼ ã€‚');
                    } else {
                        throw new Error('JSONè§£æé”™è¯¯: ' + parseError.message + 
                            ' (ä½ç½®: ' + (parseError.message.match(/position (\d+)/) ? 
                            parseError.message.match(/position (\d+)/)[1] : 'æœªçŸ¥') + ')');
                    }
                }
                if (!data || (!data.stars && !Array.isArray(data))) {
                    throw new Error('æ•°æ®æ ¼å¼é”™è¯¯: æ–‡ä»¶åº”åŒ…å«starsæ•°ç»„æˆ–ç›´æ¥æ˜¯æ•°ç»„æ ¼å¼');
                }
                
                let stars;
                if (data.stars) {
                    stars = data.stars;
                } else if (Array.isArray(data)) {
                    stars = data;
                } else {
                    throw new Error('æ•°æ®æ ¼å¼é”™è¯¯: æ— æ³•è¯†åˆ«æ•°æ®æ ¼å¼');
                }
                
                if (stars.length > 0 && Array.isArray(stars[0])) {
                    loadingText.textContent = 'æ­£åœ¨è½¬æ¢æ•°æ®æ ¼å¼...';
                    stars = stars.map(star => ({
                        source_id: star[0],
                        ra: star[1],
                        dec: star[2],
                        parallax: star[3],
                        pmra: star[5],
                        pmdec: star[7],
                        magnitude: star[9],
                        color_index: star[12],
                        radial_velocity: star[14],
                        l: star[20],
                        b: star[21]
                    }));
                } else if (stars.length > 0 && !Array.isArray(stars[0])) {
                    // å¯¹è±¡æ•°ç»„ï¼šå°†Gaiaå­—æ®µåè§„èŒƒä¸ºå‰ç«¯ç»Ÿä¸€å­—æ®µ
                    loadingText.textContent = 'æ­£åœ¨è§„èŒƒå­—æ®µ...';
                    stars = normalizeStarsObjectArray(stars);
                }
                
                if (stars.length === 0) {
                    throw new Error('æ•°æ®æ–‡ä»¶ä¸ºç©º');
                }
                
                starData = stars;
                // æš´éœ²åˆ°å…¨å±€ï¼Œä¾›æµå¼åŠ è½½ç³»ç»Ÿä½¿ç”¨
                window.starData = starData;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰é¢„å¤„ç†å¥½çš„å…«å‰æ ‘æ•°æ®
                if (data.star_positions && data.octree) {
                    loadingText.textContent = `æ­£åœ¨åŠ è½½å…«å‰æ ‘æ•°æ®...`;
                    starPositions = data.star_positions;
                    octree = loadOctreeFromData(data.octree);
                    // åŸºæœ¬æ ¡éªŒï¼šé•¿åº¦ä¸€è‡´ä¸”ä½ç½®ä¸ºæœ‰æ•ˆæ•°å­—ï¼Œå¦åˆ™å›é€€åˆ°æœ¬åœ°é‡å»º
                    let needRebuild = false;
                    if (!Array.isArray(starPositions) || starPositions.length !== stars.length) {
                        needRebuild = true;
                    } else {
                        // æŠ½æ ·æ£€æŸ¥è‹¥å¹²ç‚¹
                        const sampleCount = Math.min(10, starPositions.length);
                        for (let i = 0; i < sampleCount; i++) {
                            const p = starPositions[i];
                            if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y) || !Number.isFinite(p.z)) {
                                needRebuild = true;
                                break;
                            }
                        }
                        // æ£€æŸ¥ä½ç½®æ–¹å·®æ˜¯å¦å¼‚å¸¸ï¼ˆå¤§é‡ç‚¹ä¸ç¬¬ä¸€ä¸ªç‚¹é‡åˆï¼Œå¸¸è§äºé¢„å¤„ç†é”™è¯¯ï¼‰
                        if (!needRebuild && starPositions.length > 1) {
                            const first = starPositions[0];
                            let sameCount = 0;
                            const checkN = Math.min(50, starPositions.length);
                            for (let i = 1; i < checkN; i++) {
                                const p = starPositions[i];
                                if (p && Math.abs(p.x - first.x) < 1e-9 && Math.abs(p.y - first.y) < 1e-9 && Math.abs(p.z - first.z) < 1e-9) {
                                    sameCount++;
                                }
                            }
                            // è‹¥å¤§éƒ¨åˆ†é‡‡æ ·ç‚¹ä¸ç¬¬ä¸€ä¸ªç‚¹é‡åˆï¼Œåˆ™è§†ä¸ºæ— æ•ˆ
                            if (sameCount > (checkN - 1) * 0.8) {
                                needRebuild = true;
                            }
                        }
                        // æ£€æŸ¥å…«å‰æ ‘ä¸­æ˜¯å¦å­˜åœ¨æœ‰æ•ˆçš„æ˜Ÿç´¢å¼•
                        if (!needRebuild && octree) {
                            const getFirstValidStarIndex = (node) => {
                                if (!node) return -1;
                                if (node.stars && node.stars.length > 0) {
                                    for (let idx of node.stars) {
                                        if (Number.isInteger(idx) && idx >= 0 && idx < stars.length) return idx;
                                    }
                                }
                                if (node.children) {
                                    for (let c of node.children) {
                                        const r = getFirstValidStarIndex(c);
                                        if (r >= 0) return r;
                                    }
                                }
                                return -1;
                            };
                            const anyIdx = getFirstValidStarIndex(octree);
                            if (anyIdx < 0) {
                                needRebuild = true;
                            }
                        }
                    }
                    if (needRebuild) {
                        loadingText.textContent = `é¢„å¤„ç†æ•°æ®å¼‚å¸¸ï¼Œæ­£åœ¨æœ¬åœ°é‡å»ºå…«å‰æ ‘...`;
                        octree = buildOctree(stars, 3);
                    }
                    
                    if (stars.length > 0 && !Array.isArray(stars[0])) {
                        // éªŒè¯ç¬¬ä¸€ä¸ªæ’æ˜Ÿæ˜¯å¦æœ‰é€Ÿåº¦æ•°æ®
                        const firstStar = stars[0];
                        const hasPmra = firstStar && (firstStar.pmra !== null && firstStar.pmra !== undefined);
                        const hasPmdec = firstStar && (firstStar.pmdec !== null && firstStar.pmdec !== undefined);
                        const hasRadialVelocity = firstStar && (firstStar.radial_velocity !== null && firstStar.radial_velocity !== undefined);
                        
                        if (hasPmra || hasPmdec || hasRadialVelocity) {
                            console.log('é¢„å¤„ç†æ•°æ®åŒ…å«é€Ÿåº¦å­—æ®µ:', {
                                pmra: firstStar.pmra,
                                pmdec: firstStar.pmdec,
                                radial_velocity: firstStar.radial_velocity,
                                hasPmra: hasPmra,
                                hasPmdec: hasPmdec,
                                hasRadialVelocity: hasRadialVelocity
                            });
                        } else {
                            console.warn('è­¦å‘Š: é¢„å¤„ç†æ•°æ®ä¸­çš„starså¯¹è±¡ç¼ºå°‘é€Ÿåº¦å­—æ®µï¼ˆpmra, pmdec, radial_velocityï¼‰ï¼Œè½¨é“åŠŸèƒ½å°†æ— æ³•ä½¿ç”¨');
                        }
                    }
                    
                    loadingText.textContent = `æ­£åœ¨æ¸²æŸ“ ${stars.length.toLocaleString()} é¢—æ’æ˜Ÿ...`;
                    createStars(starData);
                    loading.style.display = 'none';
                    
                    document.getElementById('stats').style.display = 'block';
                    document.getElementById('camera-controls').style.display = 'none';
                    document.getElementById('star-list-panel').style.display = 'flex';
                    document.getElementById('nearest-star-info').style.display = 'block';
                } else {
                    loadingText.textContent = `æ­£åœ¨æ¸²æŸ“ ${stars.length.toLocaleString()} é¢—æ’æ˜Ÿ...`;
                    createStars(starData);
                    loading.style.display = 'none';
                    
                    document.getElementById('stats').style.display = 'block';
                    document.getElementById('camera-controls').style.display = 'none';
                    document.getElementById('star-list-panel').style.display = 'flex';
                    document.getElementById('nearest-star-info').style.display = 'none';
                }
                
            } catch (error) {
                loading.style.display = 'none';
                uploadPanel.style.display = 'block';
                uploadError.textContent = 'é”™è¯¯: ' + error.message;
                uploadError.style.display = 'block';
                fileName.textContent = '';
            }
        }
        
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    const result = e.target.result;
                    // éªŒè¯æ–‡ä»¶å†…å®¹æ˜¯å¦å®Œæ•´
                    if (result === null || result === undefined) {
                        reject(new Error('æ–‡ä»¶è¯»å–ç»“æœä¸ºç©º'));
                        return;
                    }
                    // æ£€æŸ¥ç»“æœæ˜¯å¦ä¸ºå­—ç¬¦ä¸²
                    if (typeof result !== 'string') {
                        reject(new Error('æ–‡ä»¶è¯»å–ç»“æœæ ¼å¼é”™è¯¯'));
                        return;
                    }
                    // æ£€æŸ¥å­—ç¬¦ä¸²é•¿åº¦æ˜¯å¦åˆç†ï¼ˆè‡³å°‘åº”è¯¥æœ‰ä¸€äº›å†…å®¹ï¼‰
                    if (result.length === 0) {
                        reject(new Error('æ–‡ä»¶å†…å®¹ä¸ºç©º'));
                        return;
                    }
                    resolve(result);
                };
                
                reader.onerror = (e) => {
                    reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥: ' + (reader.error ? reader.error.message : 'æœªçŸ¥é”™è¯¯')));
                };
                
                reader.onabort = (e) => {
                    reject(new Error('æ–‡ä»¶è¯»å–è¢«ä¸­æ–­'));
                };
                
                reader.readAsText(file, 'UTF-8');
            });
        }
        
        async function loadStarData(limit = 1000000) {
        }

        let lastRenderTime = performance.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            updateEarthSphereInteraction();
            
            const textUpdateTime = performance.now() / 1000;
            const textDeltaTime = textUpdateTime - (animate.lastTime || textUpdateTime);
            animate.lastTime = textUpdateTime;
            updateTextSprites(textDeltaTime);
            
            const now = performance.now();
            
            if (controls && !isAnimating) {
                const deltaSeconds = (now - lastRenderTime) / 1000;
                controls.update(deltaSeconds);
            }
            lastRenderTime = now;

            const nowTime = performance.now();
            if (octree && camera && starData.length > 0 && 
                (nowTime - lastNearestStarUpdate) >= NEAREST_STAR_UPDATE_INTERVAL) {
                updateNearestStarInfo();
                updateNearbyStarMeshes(); // æ›´æ–°é™„è¿‘æ’æ˜Ÿçš„mesh
                lastNearestStarUpdate = nowTime;
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            } else {
                return;
            }

            // FPSè®¡ç®—
            frameCount++;
            const currentTime = performance.now();
            if (currentTime >= lastTime + 1000) {
                const fpsElement = document.getElementById('fps');
                if (fpsElement) {
                    fpsElement.textContent = frameCount;
                }
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // å…«å‰æ ‘èŠ‚ç‚¹
        class OctreeNode {
            constructor(bounds, level, maxLevel) {
                this.bounds = bounds; // {min: {x,y,z}, max: {x,y,z}}
                this.level = level;
                this.maxLevel = maxLevel;
                this.stars = []; // å­˜å‚¨åœ¨è¿™ä¸ªèŠ‚ç‚¹ä¸­çš„æ’æ˜Ÿç´¢å¼•
                this.children = null; // 8ä¸ªå­èŠ‚ç‚¹
            }

            // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨è¾¹ç•Œå†…
            contains(point) {
                return point.x >= this.bounds.min.x && point.x <= this.bounds.max.x &&
                       point.y >= this.bounds.min.y && point.y <= this.bounds.max.y &&
                       point.z >= this.bounds.min.z && point.z <= this.bounds.max.z;
            }

            // è·å–ç‚¹æ‰€åœ¨çš„å­èŠ‚ç‚¹ç´¢å¼• (0-7)
            getChildIndex(point) {
                const centerX = (this.bounds.min.x + this.bounds.max.x) / 2;
                const centerY = (this.bounds.min.y + this.bounds.max.y) / 2;
                const centerZ = (this.bounds.min.z + this.bounds.max.z) / 2;
                
                let index = 0;
                if (point.x >= centerX) index |= 1;
                if (point.y >= centerY) index |= 2;
                if (point.z >= centerZ) index |= 4;
                return index;
            }

            // æ’å…¥æ’æ˜Ÿ
            insert(starIndex, position) {
                if (!this.contains(position)) {
                    return false;
                }

                // å¦‚æœæ˜¯æœ€æ·±å±‚ï¼Œç›´æ¥å­˜å‚¨
                if (this.level >= this.maxLevel) {
                    this.stars.push(starIndex);
                    return true;
                }

                // å¦‚æœæ²¡æœ‰å­èŠ‚ç‚¹ï¼Œåˆ›å»ºå­èŠ‚ç‚¹
                if (!this.children) {
                    this.subdivide();
                }

                // å°è¯•æ’å…¥åˆ°å­èŠ‚ç‚¹
                const childIndex = this.getChildIndex(position);
                if (this.children[childIndex].insert(starIndex, position)) {
                    return true;
                }

                this.stars.push(starIndex);
                return true;
            }

            // åˆ›å»ºå­èŠ‚ç‚¹
            subdivide() {
                if (this.level >= this.maxLevel || this.children) {
                    return;
                }

                const centerX = (this.bounds.min.x + this.bounds.max.x) / 2;
                const centerY = (this.bounds.min.y + this.bounds.max.y) / 2;
                const centerZ = (this.bounds.min.z + this.bounds.max.z) / 2;

                this.children = [];
                for (let i = 0; i < 8; i++) {
                    const minX = (i & 1) ? centerX : this.bounds.min.x;
                    const maxX = (i & 1) ? this.bounds.max.x : centerX;
                    const minY = (i & 2) ? centerY : this.bounds.min.y;
                    const maxY = (i & 2) ? this.bounds.max.y : centerY;
                    const minZ = (i & 4) ? centerZ : this.bounds.min.z;
                    const maxZ = (i & 4) ? this.bounds.max.z : centerZ;

                    this.children.push(new OctreeNode({
                        min: { x: minX, y: minY, z: minZ },
                        max: { x: maxX, y: maxY, z: maxZ }
                    }, this.level + 1, this.maxLevel));
                }
            }

            findNearest(point, bestDistance = Infinity, bestIndex = -1) {
                // æ£€æŸ¥å½“å‰èŠ‚ç‚¹çš„æ’æ˜Ÿ
                for (const starIndex of this.stars) {
                    const starPos = starPositions[starIndex];
                    if (!starPos) continue;
                    
                    const dx = starPos.x - point.x;
                    const dy = starPos.y - point.y;
                    const dz = starPos.z - point.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance < bestDistance) {
                        bestDistance = distance;
                        bestIndex = starIndex;
                    }
                }

                // æ£€æŸ¥å­èŠ‚ç‚¹
                if (this.children) {
                    // å…ˆæ£€æŸ¥åŒ…å«ç‚¹çš„å­èŠ‚ç‚¹
                    const childIndex = this.getChildIndex(point);
                    if (this.children[childIndex]) {
                        const result = this.children[childIndex].findNearest(point, bestDistance, bestIndex);
                        bestDistance = result.distance;
                        bestIndex = result.index;
                    }

                    for (let i = 0; i < 8; i++) {
                        if (i === childIndex) continue;
                        const child = this.children[i];
                        if (!child) continue;

                        const distToBounds = this.distanceToBounds(point, child.bounds);
                        if (distToBounds < bestDistance) {
                            const result = child.findNearest(point, bestDistance, bestIndex);
                            if (result.distance < bestDistance) {
                                bestDistance = result.distance;
                                bestIndex = result.index;
                            }
                        }
                    }
                }

                return { distance: bestDistance, index: bestIndex };
            }

            // è®¡ç®—ç‚¹åˆ°è¾¹ç•Œæ¡†çš„æœ€çŸ­è·ç¦»
            distanceToBounds(point, bounds) {
                let dx = 0, dy = 0, dz = 0;

                if (point.x < bounds.min.x) dx = bounds.min.x - point.x;
                else if (point.x > bounds.max.x) dx = point.x - bounds.max.x;

                if (point.y < bounds.min.y) dy = bounds.min.y - point.y;
                else if (point.y > bounds.max.y) dy = point.y - bounds.max.y;

                if (point.z < bounds.min.z) dz = bounds.min.z - point.z;
                else if (point.z > bounds.max.z) dz = point.z - bounds.max.z;

                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            }
        }

        function loadOctreeFromData(octreeData) {
            function createNodeFromData(data) {
                const node = new OctreeNode(data.bounds, data.level, 3);
                node.stars = data.stars || [];
                if (data.children && data.children.length > 0) {
                    node.children = data.children.map(childData => createNodeFromData(childData));
                }
                return node;
            }
            return createNodeFromData(octreeData);
        }

        function buildOctree(stars, maxLevel) {
            if (stars.length === 0) return null;

            starPositions = [];
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            // æ‰¹é‡è®¡ç®—ä½ç½®å¹¶æ‰¾åˆ°è¾¹ç•Œ
            for (let i = 0; i < stars.length; i++) {
                const star = stars[i];
                const pos = convertTo3D(star.ra, star.dec, star.parallax, star.l, star.b);
                starPositions[i] = pos; // ç¼“å­˜ä½ç½®
                
                minX = Math.min(minX, pos.x);
                minY = Math.min(minY, pos.y);
                minZ = Math.min(minZ, pos.z);
                maxX = Math.max(maxX, pos.x);
                maxY = Math.max(maxY, pos.y);
                maxZ = Math.max(maxZ, pos.z);
            }

            // æ‰©å±•è¾¹ç•Œä»¥ç¡®ä¿åŒ…å«æ‰€æœ‰ç‚¹
            const padding = Math.max(maxX - minX, maxY - minY, maxZ - minZ) * 0.1;
            minX -= padding;
            minY -= padding;
            minZ -= padding;
            maxX += padding;
            maxY += padding;
            maxZ += padding;

            const root = new OctreeNode({
                min: { x: minX, y: minY, z: minZ },
                max: { x: maxX, y: maxY, z: maxZ }
            }, 0, maxLevel);

            // æ’å…¥æ‰€æœ‰æ’æ˜Ÿï¼ˆä½¿ç”¨ç¼“å­˜çš„ä½ç½®ï¼‰
            for (let i = 0; i < stars.length; i++) {
                const pos = starPositions[i];
                root.insert(i, pos);
            }

            return root;
        }

        function convertStarToMesh(starIndex) {
            if (starMeshes.has(starIndex)) {
                return; 
            }

            const star = starData[starIndex];
            if (!star) return;

            const starPos = convertTo3D(star.ra, star.dec, star.parallax, star.l, star.b);
            const baseColor = getStarColor(star.color_index);
            // åº”ç”¨å’Œç‚¹äº‘ç›¸åŒçš„äº®åº¦ï¼ˆä¹˜ä»¥brightnessï¼‰
            const color = baseColor.clone().multiplyScalar(brightness);
            const size = getStarSize(star.magnitude) / 8;

            // åˆ›å»ºçƒä½“meshï¼Œå¤§å¹…æé«˜åœ†åº¦ï¼ˆå¢åŠ åˆ†æ®µæ•°ï¼‰
            const geometry = new THREE.SphereGeometry(size, 64, 64);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: false, // å®Œå…¨ä¸é€æ˜
                opacity: 1.0,
                side: THREE.DoubleSide // ç¡®ä¿åŒé¢æ¸²æŸ“
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(starPos.x, starPos.y, starPos.z);
            mesh.userData.starIndex = starIndex;
            mesh.renderOrder = 999; // ç¡®ä¿meshåœ¨ç‚¹äº‘ä¹‹ä¸Š
            mesh.name = `starMesh_${starIndex}`; // æ·»åŠ åç§°ä¾¿äºè°ƒè¯•

            scene.add(mesh);
            starMeshes.set(starIndex, mesh);
            convertedToMeshStars.add(starIndex);
            
            console.log(`å·²åˆ›å»ºmesh: æ’æ˜Ÿç´¢å¼•=${starIndex}, ä½ç½®=(${starPos.x.toFixed(2)}, ${starPos.y.toFixed(2)}, ${starPos.z.toFixed(2)}), å¤§å°=${size.toFixed(6)}`);
            
            hideStarInPointCloud(starIndex);
        }
        
        function hideStarInPointCloud(starIndex) {
            if (!glowGeometry || !solidGeometry) return;
            
            const glowSizeAttr = glowGeometry.getAttribute('size');
            const solidSizeAttr = solidGeometry.getAttribute('size');
            
            if (glowSizeAttr && starIndex < glowSizeAttr.count) {
                glowSizeAttr.array[starIndex] = 0;
                glowSizeAttr.needsUpdate = true;
            }
            
            if (solidSizeAttr && starIndex < solidSizeAttr.count) {
                solidSizeAttr.array[starIndex] = 0;
                solidSizeAttr.needsUpdate = true;
            }
        }
        
        function restoreStarInPointCloud(starIndex) {
            if (!glowGeometry || !solidGeometry || !starData || starIndex >= starData.length) return;
            
            const star = starData[starIndex];
            if (!star) return;
            
            const starPos = convertTo3D(star.ra, star.dec, star.parallax, star.l, star.b);
            const color = getStarColor(star.color_index);
            const size = getStarSize(star.magnitude);
            
            const glowPosAttr = glowGeometry.getAttribute('position');
            const glowColorAttr = glowGeometry.getAttribute('color');
            const glowSizeAttr = glowGeometry.getAttribute('size');
            const solidPosAttr = solidGeometry.getAttribute('position');
            const solidColorAttr = solidGeometry.getAttribute('color');
            const solidSizeAttr = solidGeometry.getAttribute('size');
            
            if (glowPosAttr && starIndex < glowPosAttr.count) {
                glowPosAttr.array[starIndex * 3] = starPos.x;
                glowPosAttr.array[starIndex * 3 + 1] = starPos.y;
                glowPosAttr.array[starIndex * 3 + 2] = starPos.z;
                glowPosAttr.needsUpdate = true;
                
                if (glowColorAttr) {
                    glowColorAttr.array[starIndex * 3] = color.r;
                    glowColorAttr.array[starIndex * 3 + 1] = color.g;
                    glowColorAttr.array[starIndex * 3 + 2] = color.b;
                    glowColorAttr.needsUpdate = true;
                }
                
                if (glowSizeAttr) {
                    glowSizeAttr.array[starIndex] = size * 1.5;
                    glowSizeAttr.needsUpdate = true;
                }
            }
            
            if (solidPosAttr && starIndex < solidPosAttr.count) {
                solidPosAttr.array[starIndex * 3] = starPos.x;
                solidPosAttr.array[starIndex * 3 + 1] = starPos.y;
                solidPosAttr.array[starIndex * 3 + 2] = starPos.z;
                solidPosAttr.needsUpdate = true;
                
                if (solidColorAttr) {
                    solidColorAttr.array[starIndex * 3] = color.r;
                    solidColorAttr.array[starIndex * 3 + 1] = color.g;
                    solidColorAttr.array[starIndex * 3 + 2] = color.b;
                    solidColorAttr.needsUpdate = true;
                }
                
                if (solidSizeAttr) {
                    solidSizeAttr.array[starIndex] = size * 0.6;
                    solidSizeAttr.needsUpdate = true;
                }
            }
        }

        function removeStarMesh(starIndex) {
            const mesh = starMeshes.get(starIndex);
            if (mesh) {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
                starMeshes.delete(starIndex);
                convertedToMeshStars.delete(starIndex);
                
                // æ¢å¤ç‚¹äº‘ä¸­çš„æ’æ˜Ÿ
                restoreStarInPointCloud(starIndex);
            }
        }

        function updateNearbyStarMeshes() {
            if (!camera || starData.length === 0) return;

            const cameraPos = {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z
            };

            if (currentFocusedStarIndex >= 0 && currentFocusedStarIndex < starData.length) {
                const star = starData[currentFocusedStarIndex];
                const starPos = convertTo3D(star.ra, star.dec, star.parallax, star.l, star.b);
                const dx = starPos.x - cameraPos.x;
                const dy = starPos.y - cameraPos.y;
                const dz = starPos.z - cameraPos.z;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                // å¦‚æœè·ç¦»åœ¨é˜ˆå€¼å†…ï¼Œè½¬æ¢ä¸ºmesh
                if (distance <= MESH_CONVERSION_DISTANCE) {
                    convertStarToMesh(currentFocusedStarIndex);
                } else {
                    // å¦‚æœè·ç¦»è¶…å‡ºé˜ˆå€¼ï¼Œç§»é™¤mesh
                    removeStarMesh(currentFocusedStarIndex);
                    
                }
            }

            if (octree) {
                const nearbyStars = findStarsInRadius(cameraPos, MESH_CONVERSION_DISTANCE);
                
                const maxMeshes = 50; // æœ€å¤šåŒæ—¶æ˜¾ç¤º50ä¸ªmesh
                for (let i = 0; i < Math.min(nearbyStars.length, maxMeshes); i++) {
                    convertStarToMesh(nearbyStars[i]);
                }

                // ç§»é™¤è¶…å‡ºè·ç¦»çš„mesh
                starMeshes.forEach((mesh, starIndex) => {
                    const star = starData[starIndex];
                    if (!star) {
                        removeStarMesh(starIndex);
                        return;
                    }
                    const starPos = convertTo3D(star.ra, star.dec, star.parallax, star.l, star.b);
                    const dx = starPos.x - cameraPos.x;
                    const dy = starPos.y - cameraPos.y;
                    const dz = starPos.z - cameraPos.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance > MESH_CONVERSION_DISTANCE * 1.5) { 
                        removeStarMesh(starIndex);
                    }
                });
            }
        }

        function findStarsInRadius(center, radius) {
            const result = [];
            if (!octree || !starPositions) return result;

            function searchNode(node) {
                const distToBounds = node.distanceToBounds(center, node.bounds);
                if (distToBounds > radius) return;

                for (const starIndex of node.stars) {
                    const starPos = starPositions[starIndex];
                    if (!starPos) continue;
                    
                    const dx = starPos.x - center.x;
                    const dy = starPos.y - center.y;
                    const dz = starPos.z - center.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    if (distance <= radius) {
                        result.push(starIndex);
                    }
                }

                if (node.children) {
                    for (const child of node.children) {
                        searchNode(child);
                    }
                }
            }

            searchNode(octree);
            return result;
        }

        function updateNearestStarInfo() {
            if (!octree || !camera || starData.length === 0) return;

            const cameraPos = {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z
            };

            const result = octree.findNearest(cameraPos);
            
            if (result.index >= 0) {
                const star = starData[result.index];
                const distanceElement = document.getElementById('nearest-star-distance');
                const idElement = document.getElementById('nearest-star-id');
                
                if (distanceElement) {
                    distanceElement.textContent = (result.distance * 10000).toFixed(2) + ' å•ä½';
                }
                if (idElement) {
                    idElement.textContent = star.source_id ? star.source_id.toString() : 'æœªçŸ¥';
                }
            }
        }

        function updateStarList() {
            const starList = document.getElementById('star-list');
            const starListCount = document.getElementById('star-list-count');
            const starSearch = document.getElementById('star-search');
            
            if (!starList || !starData || starData.length === 0) {
                return;
            }
            
            const searchTerm = starSearch ? starSearch.value.trim() : '';
            
            let filteredStars = starData;
            let filteredIndices = [];
            if (searchTerm) {
                const searchLower = searchTerm.toLowerCase();
                filteredStars = [];
                starData.forEach((star, originalIndex) => {
                    const starId = star.source_id ? star.source_id.toString() : '';
                    if (starId.toLowerCase().includes(searchLower)) {
                        filteredStars.push(star);
                        filteredIndices.push(originalIndex);
                    }
                });
            } else {
                filteredIndices = starData.map((_, index) => index);
            }
            
            // æ¸…ç©ºåˆ—è¡¨
            starList.innerHTML = '';
            
            // æ·»åŠ æ’æ˜Ÿç¼–å·åˆ°åˆ—è¡¨
            filteredStars.forEach((star, filteredIndex) => {
                const li = document.createElement('li');
                const starId = star.source_id ? star.source_id.toString() : `æœªçŸ¥-${filteredIndex}`;
                li.textContent = starId;
                li.dataset.originalIndex = filteredIndices[filteredIndex];
                li.style.cursor = 'pointer';
                li.addEventListener('click', () => {
                    const originalIndex = parseInt(li.dataset.originalIndex);
                    focusOnStar(originalIndex);
                });
                starList.appendChild(li);
            });
            
            // æ›´æ–°è®¡æ•°
            if (starListCount) {
                const totalCount = starData.length;
                const filteredCount = filteredStars.length;
                if (searchTerm) {
                    starListCount.textContent = `æ˜¾ç¤º ${filteredCount.toLocaleString()} / å…± ${totalCount.toLocaleString()} é¢—æ’æ˜Ÿ`;
                } else {
                    starListCount.textContent = `å…± ${totalCount.toLocaleString()} é¢—æ’æ˜Ÿ`;
                }
            }
        }

        function setupStarList() {
        }

        // ç¼“åŠ¨å‡½æ•°ï¼šease-in-out
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function focusOnStar(starIndex) {
            if (!starData || starIndex < 0 || starIndex >= starData.length) {
                return;
            }

            // å¦‚æœæ­£åœ¨åŠ¨ç”»ï¼Œå…ˆå–æ¶ˆ
            if (isAnimating && animationId) {
                cancelAnimationFrame(animationId);
                isAnimating = false;
            }

            // è®¾ç½®å½“å‰èšç„¦çš„æ’æ˜Ÿç´¢å¼•
            currentFocusedStarIndex = starIndex;
            isFollowing = true;

            const star = starData[starIndex];
            const starPos = convertTo3D(star.ra, star.dec, star.parallax, star.l, star.b);
            
            // è®¡ç®—å¹¶ç»˜åˆ¶è½¨é“
            calculateAndDrawOrbit(star, starPos);
            
            const starVector = new THREE.Vector3(starPos.x, starPos.y, starPos.z);
            
            const viewDistance = 0.012;
            const viewDistanceInt = HighPrecisionMath.toInt(viewDistance);
            
            const directionToStar = starVector.clone().normalize();
            const directionToStarInt = HighPrecisionMath.vec3FloatToInt(directionToStar);
            
            const backVectorInt = HighPrecisionMath.Int.multiplyScalar(directionToStarInt, viewDistanceInt);
            
            const starPosInt = HighPrecisionMath.vec3FloatToInt(starPos);
            
            const targetPositionInt = HighPrecisionMath.Int.subtractVectors(starPosInt, backVectorInt);
            
            // è½¬æ¢å›æµ®ç‚¹æ•°
            const targetPosition = HighPrecisionMath.vec3IntToFloat(targetPositionInt);

            const lookDirection = new THREE.Vector3(
                starPos.x - targetPosition.x,
                starPos.y - targetPosition.y,
                starPos.z - targetPosition.z
            ).normalize();
            
            if (isNaN(lookDirection.x) || isNaN(lookDirection.y) || isNaN(lookDirection.z) ||
                lookDirection.length() < 0.001) {
                lookDirection.copy(directionToStar);
            }
            
            // å¦‚æœæ–¹å‘å‘é‡æ— æ•ˆï¼Œä½¿ç”¨é»˜è®¤æ–¹å‘
            if (isNaN(lookDirection.x) || isNaN(lookDirection.y) || isNaN(lookDirection.z)) {
                lookDirection.set(0, 0, -1);
            }

            const cameraForward = lookDirection.clone().negate();
            const targetYaw = Math.atan2(cameraForward.x, cameraForward.z);
            const targetPitch = Math.asin(-cameraForward.y);

            const startPosition = {
                x: camera.position.x,
                y: camera.position.y,
                z: camera.position.z
            };

            // è·å–å½“å‰ç›¸æœºçš„å››å…ƒæ•°
            const startQuaternion = camera.quaternion.clone();
            
            const targetYawQuat = new THREE.Quaternion();
            targetYawQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetYaw);
            const targetPitchQuat = new THREE.Quaternion();
            const xAxis = new THREE.Vector3(1, 0, 0);
            xAxis.applyQuaternion(targetYawQuat);
            targetPitchQuat.setFromAxisAngle(xAxis, targetPitch);
            const targetQuaternion = new THREE.Quaternion();
            targetQuaternion.multiplyQuaternions(targetPitchQuat, targetYawQuat);
            targetQuaternion.normalize();

            isAnimating = true;
            let lastTime = performance.now();
            // è¿›å…¥åœé åŠå¾„åçš„ç¯ç»•å‚æ•°ï¼ˆ2åˆ†é’Ÿä¸€åœˆï¼‰
            const orbitAngularSpeed = (2 * Math.PI) / (2 * 60); // rad/sï¼Œç¯ç»•é€Ÿåº¦ï¼ˆä¸åŠ é€Ÿï¼‰
            let orbitAngle = null; // åœ¨è¿›å…¥ç¯ç»•æ—¶åˆå§‹åŒ–
            
            // è·ç¦»é˜ˆå€¼å®šä¹‰ï¼ˆä½¿ç”¨ç»å¯¹è·ç¦»ï¼‰
            const DECELERATION_START_DISTANCE = 0.4; // UIæ˜¾ç¤º4000ï¼Œå¼€å§‹å‡é€Ÿ
            const ARRIVAL_DISTANCE = 0.012; // UIæ˜¾ç¤º120ï¼Œé™åˆ°0å¹¶å¼€å§‹ç¯ç»•
            
            function animateCamera() {
                if (!isAnimating) return;
                
                const now = performance.now();
                const dt = Math.max(0, (now - lastTime) / 1000);
                lastTime = now;
                
                if (!isAnimating) return;
                
                // è¯»å–å½“å‰é€Ÿåº¦è®¾ç½®ï¼ˆä¸é”®ç›˜ç§»åŠ¨ä¸€è‡´ï¼‰
                const baseSpeed = HighPrecisionMath.toFloat(controls.moveSpeed || HighPrecisionMath.toInt(10));
                const mult1 = controls.speedMultiplier1 ? controls.speedMultiplier1 : 1.0;
                const mult2 = controls.speedMultiplier2 ? controls.speedMultiplier2 : 1.0;
                const mult3 = controls.speedMultiplier3 ? controls.speedMultiplier3 : 1.0;
                const maxSpeedPerSec = Math.max(1e-8, baseSpeed * mult1 * mult2 * mult3 * 10); // ä¸–ç•Œå•ä½/ç§’ï¼ˆæé«˜10å€ï¼‰
                
                // å½“å‰å®é™…ä½ç½®ä¸æ—‹è½¬
                const curPos = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
                const toStar = new THREE.Vector3(
                    starPos.x - curPos.x,
                    starPos.y - curPos.y,
                    starPos.z - curPos.z
                );
                const dist = toStar.length(); // ä½¿ç”¨ç»å¯¹è·ç¦»
                const MIN_DISTANCE = 1e-10; // æœ€å°æœ‰æ•ˆè·ç¦»
                if (dist < MIN_DISTANCE) {
                    // è·ç¦»è¿‡å°ï¼Œç›´æ¥è¿›å…¥ç¯ç»•æ¨¡å¼
                    animationId = requestAnimationFrame(animateCamera);
                    return;
                }
                
                const ORBIT_THRESHOLD = ARRIVAL_DISTANCE * 1.1; 
                if (dist <= ORBIT_THRESHOLD) {
                    // â€”â€” ç¯ç»•æ’æ˜Ÿï¼ˆ2åˆ†é’Ÿä¸€åœˆï¼‰ â€”â€”
                    // æ–‡å­—å¼¹å‡ºï¼šç¯ç»•æ—¶ç”Ÿæˆæ–‡å­—ï¼ˆä»æ›´é è¿‘æ’æ˜Ÿçš„ä½ç½®å¼¹å‡ºï¼‰
                    if (currentFocusedStarIndex >= 0 && !starTextIndexMap.has(currentFocusedStarIndex)) {
                        textSpawnTimer += dt;
                        if (textSpawnTimer >= textSpawnInterval) {
                            textSpawnTimer = 0;
                            const textIndex = starTextIndexMap.size % textPool.length;
                            const selectedText = textPool[textIndex];
                            starTextIndexMap.set(currentFocusedStarIndex, textIndex);
                            const textPos = new THREE.Vector3().lerpVectors(curPos, starPos, 0.7);
                            createTextSprite(selectedText, textPos);
                        }
                    }
                    // åˆå§‹åŒ–ç¯ç»•è§’ï¼šåŸºäºå½“å‰ç›¸å¯¹ä½ç½®åœ¨XZå¹³é¢çš„ç›¸ä½
                    if (orbitAngle === null) {
                        orbitAngle = Math.atan2(curPos.z - starPos.z, curPos.x - starPos.x);
                        // æ£€æŸ¥è§’åº¦æ˜¯å¦æœ‰æ•ˆ
                        if (isNaN(orbitAngle)) {
                            orbitAngle = 0;
                        }
                        // å¦‚æœæ˜¯è‡ªåŠ¨æ¼«æ¸¸ï¼Œè®°å½•èµ·å§‹æ—¶é—´
                        if (autoTourActive && autoTourStartTime === null) {
                            autoTourStartTime = now;
                        }
                    }
                    orbitAngle += orbitAngularSpeed * dt;
                    
                    // è‡ªåŠ¨æ¼«æ¸¸ï¼šæ£€æµ‹æ˜¯å¦è¾¾åˆ°5ç§’
                    if (autoTourActive && !autoTourPaused && autoTourStartTime !== null) {
                        // è®¡ç®—ä»å¼€å§‹ç¯ç»•åˆ°ç°åœ¨çš„ç»è¿‡æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
                        const elapsedTime = now - autoTourStartTime;
                        // å¦‚æœè¾¾åˆ°æˆ–è¶…è¿‡5ç§’ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ’æ˜Ÿ
                        if (elapsedTime >= AUTO_TOUR_ORBIT_DURATION) {
                            autoTourStartTime = null;
                            // åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ’æ˜Ÿ
                            moveToNextStarInAutoTour();
                            return;
                        }
                    }
                    
                    // ç¨³å®šæ€§æ”¹è¿›ï¼šç¡®ä¿è§’åº¦åœ¨æœ‰æ•ˆèŒƒå›´å†…
                    if (isNaN(orbitAngle)) {
                        orbitAngle = 0;
                    }
                    
                    // ä»…åœ¨XZå¹³é¢ç¯ç»•ï¼ŒåŠå¾„ä¸ºARRIVAL_DISTANCEï¼ŒYä¸æ’æ˜Ÿä¿æŒä¸€è‡´
                    const orbitX = starPos.x + ARRIVAL_DISTANCE * Math.cos(orbitAngle);
                    const orbitZ = starPos.z + ARRIVAL_DISTANCE * Math.sin(orbitAngle);
                    const orbitY = starPos.y;
                    const nextPos = new THREE.Vector3(orbitX, orbitY, orbitZ);
                    
                    // æ£€æŸ¥ç¯ç»•ä½ç½®æ˜¯å¦æœ‰æ•ˆ
                    if (isNaN(nextPos.x) || isNaN(nextPos.y) || isNaN(nextPos.z)) {
                        animationId = requestAnimationFrame(animateCamera);
                        return;
                    }
                    
                    // æœå‘æ’æ˜Ÿ
                    const toStarOrbit = new THREE.Vector3(
                        starPos.x - nextPos.x,
                        starPos.y - nextPos.y,
                        starPos.z - nextPos.z
                    );
                    
                    // ç¨³å®šæ€§æ”¹è¿›ï¼šæ£€æŸ¥æ–¹å‘å‘é‡æ˜¯å¦æœ‰æ•ˆ
                    const toStarOrbitLength = toStarOrbit.length();
                    if (toStarOrbitLength < MIN_DISTANCE) {
                        animationId = requestAnimationFrame(animateCamera);
                        return;
                    }
                    toStarOrbit.normalize();
                    
                    const camForwardTarget = toStarOrbit.clone().negate();
                    
                    // æ£€æŸ¥æ–¹å‘å‘é‡æ˜¯å¦æœ‰æ•ˆ
                    if (isNaN(camForwardTarget.x) || isNaN(camForwardTarget.y) || isNaN(camForwardTarget.z) ||
                        camForwardTarget.length() < 0.001) {
                        animationId = requestAnimationFrame(animateCamera);
                        return;
                    }
                    
                    const targetYaw = Math.atan2(camForwardTarget.x, camForwardTarget.z);
                    const targetPitch = Math.asin(Math.max(-1, Math.min(1, -camForwardTarget.y))); // é™åˆ¶asinè¾“å…¥èŒƒå›´
                    
                    // æ£€æŸ¥è§’åº¦æ˜¯å¦æœ‰æ•ˆ
                    if (isNaN(targetYaw) || isNaN(targetPitch)) {
                        animationId = requestAnimationFrame(animateCamera);
                        return;
                    }
                    
                    const yawQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetYaw);
                    const xAxis = new THREE.Vector3(1, 0, 0).applyQuaternion(yawQuat);
                    const pitchQuat = new THREE.Quaternion().setFromAxisAngle(xAxis, targetPitch);
                    const lookQuat = new THREE.Quaternion().multiplyQuaternions(pitchQuat, yawQuat).normalize();
                    
                    // æ£€æŸ¥å››å…ƒæ•°æ˜¯å¦æœ‰æ•ˆ
                    if (isNaN(lookQuat.x) || isNaN(lookQuat.y) || isNaN(lookQuat.z) || isNaN(lookQuat.w)) {
                        animationId = requestAnimationFrame(animateCamera);
                        return;
                    }
                    
                    // å¹³æ»‘æ—‹è½¬ï¼ˆä¿®å¤æŠ–åŠ¨ï¼šå¼ºåˆ¶é‡‡ç”¨æœ€çŸ­å¼§ï¼›é¿å…è·¨Ï€æ—¶çš„é¢ ç°¸ï¼‰
                    const curQuat = camera.quaternion.clone();
                    const slerpPerSec = 6.0; // ç•¥åŠ å¿«è¿½éšï¼Œå‡å°‘æ»åå¼•èµ·çš„å¾®æŠ–
                    const slerpT = Math.min(1, slerpPerSec * dt);
                    const targetQuat = lookQuat.clone();
                    // è‹¥ç‚¹ç§¯ä¸ºè´Ÿï¼Œå–åç›®æ ‡å››å…ƒæ•°ä»¥èµ°æœ€çŸ­è·¯å¾„
                    if (curQuat.dot(targetQuat) < 0) {
                        targetQuat.x *= -1; targetQuat.y *= -1; targetQuat.z *= -1; targetQuat.w *= -1;
                    }
                    const rotatedQuat = new THREE.Quaternion();
                    rotatedQuat.slerpQuaternions(curQuat, targetQuat, slerpT);
                    
                    // æ£€æŸ¥æ—‹è½¬åçš„å››å…ƒæ•°æ˜¯å¦æœ‰æ•ˆ
                    if (!isNaN(rotatedQuat.x) && !isNaN(rotatedQuat.y) && !isNaN(rotatedQuat.z) && !isNaN(rotatedQuat.w)) {
                        // å†™å›ä½ç½®ä¸æ—‹è½¬
                        controls.positionInt.x = HighPrecisionMath.toInt(nextPos.x);
                        controls.positionInt.y = HighPrecisionMath.toInt(nextPos.y);
                        controls.positionInt.z = HighPrecisionMath.toInt(nextPos.z);
                        camera.position.copy(nextPos);
                        camera.quaternion.copy(rotatedQuat);
                        controls.quaternion.copy(rotatedQuat);
                    }
                    
                    animationId = requestAnimationFrame(animateCamera);
                    return;
                }
                
                const desiredDir = toStar.clone();
                const desiredDirLength = desiredDir.length();
                if (desiredDirLength < MIN_DISTANCE) {
                    // æ–¹å‘å‘é‡æ— æ•ˆï¼Œè·³è¿‡è¿™ä¸€å¸§
                    animationId = requestAnimationFrame(animateCamera);
                    return;
                }
                desiredDir.normalize(); // æœŸæœ›æœå‘ï¼ˆæŒ‡å‘æ’æ˜Ÿï¼‰
                
                // ç”±desiredDirè®¡ç®—ç›®æ ‡å››å…ƒæ•°ï¼ˆç›¸æœºæœå‘æ˜¯ -Zï¼‰
                const cameraForwardTarget = desiredDir.clone().negate(); // ç›®æ ‡å‰å‘ï¼ˆ-Zå¯¹å‡†æ’æ˜Ÿæ–¹å‘ï¼‰
                
                // ç¨³å®šæ€§æ”¹è¿›ï¼šæ£€æŸ¥æ–¹å‘å‘é‡æ˜¯å¦æœ‰æ•ˆ
                if (isNaN(cameraForwardTarget.x) || isNaN(cameraForwardTarget.y) || isNaN(cameraForwardTarget.z) ||
                    cameraForwardTarget.length() < 0.001) {
                    animationId = requestAnimationFrame(animateCamera);
                    return;
                }
                
                const targetYaw = Math.atan2(cameraForwardTarget.x, cameraForwardTarget.z);
                const targetPitch = Math.asin(Math.max(-1, Math.min(1, -cameraForwardTarget.y))); // é™åˆ¶asinè¾“å…¥èŒƒå›´
                
                // æ£€æŸ¥è§’åº¦æ˜¯å¦æœ‰æ•ˆ
                if (isNaN(targetYaw) || isNaN(targetPitch)) {
                    animationId = requestAnimationFrame(animateCamera);
                    return;
                }
                
                const yawQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetYaw);
                const xAxis = new THREE.Vector3(1, 0, 0).applyQuaternion(yawQuat);
                const pitchQuat = new THREE.Quaternion().setFromAxisAngle(xAxis, targetPitch);
                const targetLookQuat = new THREE.Quaternion().multiplyQuaternions(pitchQuat, yawQuat).normalize();
                
                // æ£€æŸ¥å››å…ƒæ•°æ˜¯å¦æœ‰æ•ˆ
                if (isNaN(targetLookQuat.x) || isNaN(targetLookQuat.y) || isNaN(targetLookQuat.z) || isNaN(targetLookQuat.w)) {
                    animationId = requestAnimationFrame(animateCamera);
                    return;
                }
                
                if (dist <= TEXT_SPAWN_DISTANCE && currentFocusedStarIndex >= 0 && !starTextIndexMap.has(currentFocusedStarIndex)) {
                    const cameraForward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const toStarNormalized = toStar.clone().normalize();
                    const dot = cameraForward.dot(toStarNormalized);
                    const facingAngle = Math.acos(Math.max(-1, Math.min(1, dot)));
                    
                    if (facingAngle < Math.PI / 6) { // 30åº¦ = Ï€/6
                        textSpawnTimer += dt;
                        if (textSpawnTimer >= textSpawnInterval) {
                            textSpawnTimer = 0;
                            const textIndex = starTextIndexMap.size % textPool.length;
                            const selectedText = textPool[textIndex];
                            starTextIndexMap.set(currentFocusedStarIndex, textIndex);
                            const textPos = new THREE.Vector3().lerpVectors(curPos, starPos, 0.95);
                            createTextSprite(selectedText, textPos);
                        }
                    }
                }
                
                const curQuat = camera.quaternion.clone();
                // ä¼°ç®—å½“å‰ä¸ç›®æ ‡çš„å¤¹è§’
                const dot = Math.min(1, Math.max(-1, curQuat.dot(targetLookQuat)));
                const angle = 2 * Math.acos(Math.abs(dot));
                const angleThreshold = 0.01; // å¼§åº¦é˜ˆå€¼ï¼ˆçº¦0.57Â°ï¼‰ï¼Œç¨å¾®å¢å¤§ä»¥æé«˜ç¨³å®šæ€§
                // æ¯ç§’æœç›®æ ‡å‰è¿›çš„slerpæ¯”ä¾‹ï¼ˆ0-1ï¼‰ï¼Œå¯æ ¹æ®éœ€è¦è°ƒèŠ‚æ—‹è½¬é€Ÿåº¦
                const slerpPerSec = 4.0;
                const slerpT = Math.min(1, slerpPerSec * dt);
                const rotatedQuat = new THREE.Quaternion();
                rotatedQuat.slerpQuaternions(curQuat, targetLookQuat, slerpT);
                
                // æ£€æŸ¥æ—‹è½¬åçš„å››å…ƒæ•°æ˜¯å¦æœ‰æ•ˆ
                if (!isNaN(rotatedQuat.x) && !isNaN(rotatedQuat.y) && !isNaN(rotatedQuat.z) && !isNaN(rotatedQuat.w)) {
                    camera.quaternion.copy(rotatedQuat);
                    controls.quaternion.copy(rotatedQuat);
                }
                
                // 2) åªæœ‰å½“è½¬å‘åŸºæœ¬å®Œæˆåï¼Œæ‰è¿›è¡Œä½ç§»
                let nextPos = curPos;
                if (angle <= angleThreshold) {
                    let speedFactor = 1.0;
                    
                    // ä½¿ç”¨ç¨å¾®å¤§ä¸€ç‚¹çš„é˜ˆå€¼æ¥ç¡®ä¿èƒ½è¿›å…¥ç¯ç»•æ¨¡å¼
                    const ORBIT_THRESHOLD_FOR_SPEED = ARRIVAL_DISTANCE * 1.1;
                    
                    if (dist <= ORBIT_THRESHOLD_FOR_SPEED) {
                        // å·²åˆ°è¾¾ç¯ç»•è·ç¦»ï¼Œé€Ÿåº¦ä¸º0
                        speedFactor = 0;
                    } else if (dist < DECELERATION_START_DISTANCE) {
                        if (dist >= 0.2) {
                            const t = (dist - 0.2) / (0.4 - 0.2); // 0åˆ°1ï¼Œ0è¡¨ç¤ºåœ¨2000ï¼Œ1è¡¨ç¤ºåœ¨4000
                            speedFactor = 0.5 + 0.5 * (1 - t * t); // ä½¿ç”¨å¹³æ–¹åŠ é€Ÿå‡é€Ÿ
                        } else if (dist >= 0.1) {
                            const t = (dist - 0.1) / (0.2 - 0.1); // 0åˆ°1ï¼Œ0è¡¨ç¤ºåœ¨1000ï¼Œ1è¡¨ç¤ºåœ¨2000
                            speedFactor = 0.25 + 0.25 * (1 - t * t); // ä½¿ç”¨å¹³æ–¹åŠ é€Ÿå‡é€Ÿ
                        } else if (dist >= 0.05) {
                            const t = (dist - 0.05) / (0.1 - 0.05); // 0åˆ°1ï¼Œ0è¡¨ç¤ºåœ¨500ï¼Œ1è¡¨ç¤ºåœ¨1000
                            speedFactor = 0.125 + 0.125 * (1 - t * t); // ä½¿ç”¨å¹³æ–¹åŠ é€Ÿå‡é€Ÿ
                        } else {
                            const t = (dist - ARRIVAL_DISTANCE) / (0.05 - ARRIVAL_DISTANCE); // 0åˆ°1ï¼Œ0è¡¨ç¤ºåœ¨120ï¼Œ1è¡¨ç¤ºåœ¨500
                            speedFactor = 0.125 * (1 - t * t); // ä½¿ç”¨å¹³æ–¹åŠ é€Ÿå‡é€Ÿ
                        }
                        speedFactor = Math.max(0, Math.min(1, speedFactor)); // é™åˆ¶åœ¨0-1ä¹‹é—´
                    }

                    const finalSpeedPerSec = maxSpeedPerSec * speedFactor;
                    
                    const maxStepPerFrame = dist * 0.5; // å•å¸§æœ€å¤šç§»åŠ¨å½“å‰è·ç¦»çš„50%
                    const step = Math.min(
                        finalSpeedPerSec * dt, 
                        Math.max(0, dist - ARRIVAL_DISTANCE),
                        maxStepPerFrame
                    );
                    
                    if (desiredDir.length() < MIN_DISTANCE) {
                        animationId = requestAnimationFrame(animateCamera);
                        return;
                    }
                    
                    const moveDir = desiredDir.clone().normalize(); // ç¡®ä¿å·²å½’ä¸€åŒ–
                    
                    if (isNaN(moveDir.x) || isNaN(moveDir.y) || isNaN(moveDir.z) || 
                        isNaN(step) || step < 0 || step > dist) {
                        animationId = requestAnimationFrame(animateCamera);
                        return;
                    }
                    
                    nextPos = new THREE.Vector3(
                        curPos.x + moveDir.x * step,
                        curPos.y + moveDir.y * step,
                        curPos.z + moveDir.z * step
                    );
                    
                    // æ£€æŸ¥æ–°ä½ç½®æ˜¯å¦æœ‰æ•ˆ
                    if (!isNaN(nextPos.x) && !isNaN(nextPos.y) && !isNaN(nextPos.z)) {
                        controls.positionInt.x = HighPrecisionMath.toInt(nextPos.x);
                        controls.positionInt.y = HighPrecisionMath.toInt(nextPos.y);
                        controls.positionInt.z = HighPrecisionMath.toInt(nextPos.z);
                        camera.position.copy(nextPos);
                    }
                } else {
                    // æœªå¯¹å‡†æ—¶ä¿æŒå½“å‰ä½ç½®ï¼Œä»…æ›´æ–°æ—‹è½¬
                    controls.positionInt.x = HighPrecisionMath.toInt(curPos.x);
                    controls.positionInt.y = HighPrecisionMath.toInt(curPos.y);
                    controls.positionInt.z = HighPrecisionMath.toInt(curPos.z);
                }
                
                animationId = requestAnimationFrame(animateCamera);
            }
            animationId = requestAnimationFrame(animateCamera);
        }

        function setupControls() {
            const highPrecisionToggle = document.getElementById('high-precision-toggle');
            if (highPrecisionToggle) {
                highPrecisionToggle.addEventListener('change', (e) => {
                    if (controls) {
                        controls.setHighPrecisionMode(e.target.checked);
                    }
                });
            }
            
            const cameraSpeedSlider = document.getElementById('camera-speed-slider');
            if (cameraSpeedSlider) {
                cameraSpeedSlider.addEventListener('input', (e) => {
                    const speed = parseFloat(e.target.value);
                    if (controls) {
                        // è½¬æ¢ä¸ºæ•´æ•°é€Ÿåº¦
                        controls.moveSpeed = HighPrecisionMath.toInt(speed);
                    }
                    const speedValue = document.getElementById('camera-speed-value');
                    if (speedValue) speedValue.textContent = speed;
                });
                // éšè—é€Ÿåº¦æ»‘å—
                if (cameraSpeedSlider.parentElement) {
                    cameraSpeedSlider.parentElement.style.display = 'none';
                }
            }

            const speedMultiplier1Slider = document.getElementById('speed-multiplier1-slider');
            if (speedMultiplier1Slider) {
                speedMultiplier1Slider.addEventListener('input', (e) => {
                    const logValue = parseFloat(e.target.value);
                    const multiplier = Math.pow(10, logValue);
                    speedMultiplier1 = multiplier;
                    if (controls) {
                        controls.speedMultiplier1 = multiplier;
                    }
                    const multiplierValue = document.getElementById('speed-multiplier1-value');
                    const multiplierPercent = document.getElementById('speed-multiplier1-percent');
                    if (multiplierValue) multiplierValue.textContent = multiplier.toFixed(2);
                    if (multiplierPercent) multiplierPercent.textContent = (multiplier * 100).toFixed(0);
                });
            }

            const speedMultiplier2Slider = document.getElementById('speed-multiplier2-slider');
            if (speedMultiplier2Slider) {
                speedMultiplier2Slider.addEventListener('input', (e) => {
                    const logValue = parseFloat(e.target.value);
                    const multiplier = Math.pow(10, logValue);
                    speedMultiplier2 = multiplier;
                    if (controls) {
                        controls.speedMultiplier2 = multiplier;
                    }
                    const multiplierValue = document.getElementById('speed-multiplier2-value');
                    const multiplierPercent = document.getElementById('speed-multiplier2-percent');
                    if (multiplierValue) multiplierValue.textContent = multiplier.toFixed(2);
                    if (multiplierPercent) multiplierPercent.textContent = (multiplier * 100).toFixed(0);
                });
            }

            const speedMultiplier3Slider = document.getElementById('speed-multiplier3-slider');
            if (speedMultiplier3Slider) {
                speedMultiplier3Slider.addEventListener('input', (e) => {
                    const logValue = parseFloat(e.target.value);
                    const multiplier = Math.pow(10, logValue);
                    speedMultiplier3 = multiplier;
                    if (controls) {
                        controls.speedMultiplier3 = multiplier;
                    }
                    const multiplierValue = document.getElementById('speed-multiplier3-value');
                    const multiplierPercent = document.getElementById('speed-multiplier3-percent');
                    if (multiplierValue) multiplierValue.textContent = multiplier.toFixed(2);
                    if (multiplierPercent) multiplierPercent.textContent = (multiplier * 100).toFixed(0);
                });
            }

            const limitSlider = document.getElementById('limit-slider');
            const sizeSlider = document.getElementById('size-slider');
            const brightnessSlider = document.getElementById('brightness-slider');
            const rotationSlider = document.getElementById('rotation-slider');

            if (limitSlider) {
                limitSlider.addEventListener('input', (e) => {
                    currentLimit = parseInt(e.target.value);
                    const limitValue = document.getElementById('limit-value');
                    if (limitValue) limitValue.textContent = currentLimit.toLocaleString();
                    if (starData.length > 0) {
                        createStars(starData);
                    }
                });
            }

            if (sizeSlider) {
                sizeSlider.addEventListener('input', (e) => {
                    starSize = parseFloat(e.target.value);
                    const sizeValue = document.getElementById('size-value');
                    if (sizeValue) sizeValue.textContent = starSize.toFixed(1);
                    updateStarUniforms();
                });
            }

            if (brightnessSlider) {
                brightnessSlider.addEventListener('input', (e) => {
                    brightness = parseFloat(e.target.value);
                    const brightnessValue = document.getElementById('brightness-value');
                    if (brightnessValue) brightnessValue.textContent = brightness.toFixed(1);
                    updateStarUniforms();
                });
            }

            if (rotationSlider) {
                rotationSlider.addEventListener('input', (e) => {
                    rotationSpeed = parseFloat(e.target.value);
                    const rotationValue = document.getElementById('rotation-value');
                    if (rotationValue) rotationValue.textContent = rotationSpeed.toFixed(1);
                });
            }
        }

        // åˆ›å»ºè¶…æ—¶AbortSignalçš„å…¼å®¹å‡½æ•°
        function createTimeoutSignal(timeoutMs) {
            if (AbortSignal.timeout) {
                return AbortSignal.timeout(timeoutMs);
            }
            // å…¼å®¹æ—§æµè§ˆå™¨
            const controller = new AbortController();
            setTimeout(() => controller.abort(), timeoutMs);
            return controller.signal;
        }
        
        // è‡ªåŠ¨æ£€æµ‹å†…å­˜å¹¶ä¸‹è½½æ•°æ®æ–‡ä»¶
        async function detectMemoryAndDownload() {
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loading-text');
            const uploadPanel = document.getElementById('upload-panel');
            
            if (!loading || !loadingText || !uploadPanel) return;
            
            // æ£€æµ‹å†…å­˜ï¼ˆGBï¼‰
            let memoryGB = 8; // é»˜è®¤å€¼
            if (navigator.deviceMemory) {
                memoryGB = navigator.deviceMemory;
            } else {
                // å¦‚æœä¸æ”¯æŒdeviceMemory APIï¼Œå°è¯•å…¶ä»–æ–¹æ³•
                // ä½¿ç”¨é»˜è®¤å€¼8GBï¼ˆä¿å®ˆä¼°è®¡ï¼‰
                console.log('è®¾å¤‡å†…å­˜APIä¸å¯ç”¨ï¼Œä½¿ç”¨é»˜è®¤å€¼8GB');
            }
            
            console.log(`æ£€æµ‹åˆ°è®¾å¤‡å†…å­˜: ${memoryGB}GB`);
            
            // æ ¹æ®å†…å­˜é€‰æ‹©release tag
            const memoryThreshold = 16; // 16GBé˜ˆå€¼
            const releaseTag = memoryGB >= memoryThreshold ? '2' : '1';
            const expectedSHA256 = memoryGB >= memoryThreshold 
                ? '6862e24f3b90ab3726bfd6bbcb62d8f5d9c3c8fd5dd9ac71c9934397ef162a1b'
                : '72e96ff39e12c9fb81108406a9978363109c03b90728ed05b6242bb82c9d227b';
            
            // éšè—ä¸Šä¼ é¢æ¿ï¼Œæ˜¾ç¤ºåŠ è½½ç•Œé¢
            uploadPanel.style.display = 'none';
            const uploadError = document.getElementById('upload-error');
            if (uploadError) {
                uploadError.style.display = 'none';
                uploadError.textContent = '';
            }
            loading.style.display = 'block';
            loadingText.textContent = `æ£€æµ‹åˆ°å†…å­˜: ${memoryGB}GBï¼Œæ­£åœ¨ä¸‹è½½æ•°æ®æ–‡ä»¶ (Release ${releaseTag})...`;
            
            try {
                // æ„å»ºGitHub releaseä¸‹è½½URL
                // éœ€è¦å…ˆè·å–releaseçš„assetsåˆ—è¡¨æ¥ç¡®å®šæ–‡ä»¶å
                // è¿™é‡Œæˆ‘ä»¬å°è¯•å¸¸è§çš„æ–‡ä»¶åæ ¼å¼
                const possibleFilenames = ['stars.json', 'data.json', 'galaxy-data.json', 'star-data.json'];
                let downloadUrl = null;
                let filename = null;
                
                // å®šä¹‰ä»£ç†URL
                const proxyBaseUrl = `https://apiv1.fliggylink.com/api/v1/client/subscribe?token=bc4820eb5c50f22bcb214ff928728aac`;
                const proxyApiUrl = `${proxyBaseUrl}&url=`;
                
                // å°è¯•é€šè¿‡GitHub APIè·å–release assets
                try {
                    const releaseApiUrl = `https://api.github.com/repos/Qhunliv13/galaxy-infomation/releases/tags/${releaseTag}`;
                    
                    // å…ˆå°è¯•ä½¿ç”¨ä»£ç†è·å–releaseä¿¡æ¯
                    let releaseInfoResponse;
                    try {
                        releaseInfoResponse = await fetch(proxyApiUrl + encodeURIComponent(releaseApiUrl), {
                            headers: {
                                'Accept': 'application/json'
                            },
                            signal: createTimeoutSignal(10000) // 10ç§’è¶…æ—¶
                        });
                    } catch (proxyError) {
                        console.warn('ä»£ç†è·å–releaseä¿¡æ¯å¤±è´¥ï¼Œå°è¯•ç›´æ¥è·å–:', proxyError);
                        // ä»£ç†å¤±è´¥ï¼Œå°è¯•ç›´æ¥è·å–
                        releaseInfoResponse = await fetch(releaseApiUrl, {
                            headers: {
                                'Accept': 'application/json'
                            },
                            signal: createTimeoutSignal(10000)
                        });
                    }
                    
                    if (!releaseInfoResponse.ok) {
                        throw new Error(`è·å–releaseä¿¡æ¯å¤±è´¥: ${releaseInfoResponse.status}`);
                    }
                    const releaseInfo = await releaseInfoResponse.json();
                    
                    if (releaseInfo && releaseInfo.assets && releaseInfo.assets.length > 0) {
                        // æŸ¥æ‰¾JSONæ–‡ä»¶
                        const jsonAsset = releaseInfo.assets.find(asset => 
                            asset.name && asset.name.toLowerCase().endsWith('.json')
                        );
                        if (jsonAsset) {
                            downloadUrl = jsonAsset.browser_download_url;
                            filename = jsonAsset.name;
                            console.log(`æ‰¾åˆ°æ–‡ä»¶: ${filename}`);
                        }
                    }
                } catch (apiError) {
                    console.warn('æ— æ³•é€šè¿‡APIè·å–æ–‡ä»¶ä¿¡æ¯ï¼Œå°è¯•ç›´æ¥ä¸‹è½½:', apiError);
                }
                
                // å¦‚æœæ— æ³•é€šè¿‡APIè·å–ï¼Œå°è¯•ç›´æ¥æ„å»ºURL
                if (!downloadUrl) {
                    for (const name of possibleFilenames) {
                        const testUrl = `https://github.com/Qhunliv13/galaxy-infomation/releases/download/${releaseTag}/${name}`;
                        try {
                            // å…ˆå°è¯•é€šè¿‡ä»£ç†æµ‹è¯•
                            let testResponse;
                            try {
                                testResponse = await fetch(proxyApiUrl + encodeURIComponent(testUrl), { 
                                    method: 'HEAD',
                                    headers: {
                                        'Accept': '*/*'
                                    },
                                    signal: createTimeoutSignal(10000) // 10ç§’è¶…æ—¶
                                });
                            } catch (proxyError) {
                                // ä»£ç†å¤±è´¥ï¼Œå°è¯•ç›´æ¥æµ‹è¯•
                                console.warn(`ä»£ç†æµ‹è¯• ${name} å¤±è´¥ï¼Œå°è¯•ç›´æ¥æµ‹è¯•:`, proxyError);
                                testResponse = await fetch(testUrl, { 
                                    method: 'HEAD',
                                    headers: {
                                        'Accept': '*/*'
                                    },
                                    signal: createTimeoutSignal(10000)
                                });
                            }
                            
                            if (testResponse.ok) {
                                downloadUrl = testUrl;
                                filename = name;
                                break;
                            }
                        } catch (e) {
                            continue;
                        }
                    }
                }
                
                if (!downloadUrl) {
                    throw new Error('æ— æ³•æ‰¾åˆ°å¯ä¸‹è½½çš„æ–‡ä»¶ï¼Œè¯·æ‰‹åŠ¨ä¸Šä¼ æ•°æ®æ–‡ä»¶');
                }
                
                loadingText.textContent = `æ­£åœ¨ä¸‹è½½: ${filename}...`;
                
                // å°è¯•ä¸‹è½½æ–‡ä»¶ï¼ˆå…ˆä»£ç†ï¼Œå¤±è´¥åˆ™ç›´æ¥ä¸‹è½½ï¼‰
                let response;
                try {
                    // å…ˆå°è¯•ä½¿ç”¨ä»£ç†ä¸‹è½½
                    response = await fetch(proxyApiUrl + encodeURIComponent(downloadUrl), {
                        headers: {
                            'Accept': '*/*'
                        },
                        signal: createTimeoutSignal(60000) // 60ç§’è¶…æ—¶
                    });
                } catch (proxyError) {
                    console.warn('ä»£ç†ä¸‹è½½å¤±è´¥ï¼Œå°è¯•ç›´æ¥ä¸‹è½½:', proxyError);
                    loadingText.textContent = `ä»£ç†ä¸‹è½½å¤±è´¥ï¼Œå°è¯•ç›´æ¥ä¸‹è½½: ${filename}...`;
                    // ä»£ç†å¤±è´¥ï¼Œå°è¯•ç›´æ¥ä¸‹è½½
                    response = await fetch(downloadUrl, {
                        headers: {
                            'Accept': '*/*'
                        },
                        signal: createTimeoutSignal(60000) // 60ç§’è¶…æ—¶
                    });
                }
                
                if (!response.ok) {
                    throw new Error(`ä¸‹è½½å¤±è´¥: HTTP ${response.status}`);
                }
                
                // è·å–æ–‡ä»¶å†…å®¹
                const arrayBuffer = await response.arrayBuffer();
                const fileSizeMB = arrayBuffer.byteLength / 1024 / 1024;
                loadingText.textContent = `å·²ä¸‹è½½ ${fileSizeMB.toFixed(2)} MBï¼Œæ­£åœ¨éªŒè¯æ–‡ä»¶å®Œæ•´æ€§...`;
                
                // è®¡ç®—SHA256å“ˆå¸Œ
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                
                console.log(`æ–‡ä»¶SHA256: ${hashHex}`);
                console.log(`æœŸæœ›SHA256: ${expectedSHA256}`);
                
                // éªŒè¯å“ˆå¸Œå€¼
                if (hashHex.toLowerCase() !== expectedSHA256.toLowerCase()) {
                    throw new Error(`æ–‡ä»¶å®Œæ•´æ€§éªŒè¯å¤±è´¥ï¼\næœŸæœ›: ${expectedSHA256}\nå®é™…: ${hashHex}\nè¯·é‡æ–°ä¸‹è½½æˆ–æ‰‹åŠ¨ä¸Šä¼ æ–‡ä»¶ã€‚`);
                }
                
                console.log('æ–‡ä»¶å®Œæ•´æ€§éªŒè¯é€šè¿‡');
                
                // å°†ArrayBufferè½¬æ¢ä¸ºæ–‡æœ¬
                loadingText.textContent = 'æ­£åœ¨è§£ææ–‡ä»¶å†…å®¹...';
                const decoder = new TextDecoder('utf-8');
                const fileContent = decoder.decode(arrayBuffer);
                
                // è§£æJSON
                let data;
                try {
                    data = JSON.parse(fileContent);
                } catch (parseError) {
                    throw new Error('JSONè§£æé”™è¯¯: ' + parseError.message);
                }
                
                if (!data || (!data.stars && !Array.isArray(data))) {
                    throw new Error('æ•°æ®æ ¼å¼é”™è¯¯: æ–‡ä»¶åº”åŒ…å«starsæ•°ç»„æˆ–ç›´æ¥æ˜¯æ•°ç»„æ ¼å¼');
                }
                
                let stars;
                if (data.stars) {
                    stars = data.stars;
                } else if (Array.isArray(data)) {
                    stars = data;
                } else {
                    throw new Error('æ•°æ®æ ¼å¼é”™è¯¯: æ— æ³•è¯†åˆ«æ•°æ®æ ¼å¼');
                }
                
                // å¤„ç†æ•°æ®æ ¼å¼
                if (stars.length > 0 && Array.isArray(stars[0])) {
                    loadingText.textContent = 'æ­£åœ¨è½¬æ¢æ•°æ®æ ¼å¼...';
                    stars = stars.map(star => ({
                        source_id: star[0],
                        ra: star[1],
                        dec: star[2],
                        parallax: star[3],
                        pmra: star[5],
                        pmdec: star[7],
                        magnitude: star[9],
                        color_index: star[12],
                        radial_velocity: star[14],
                        l: star[20],
                        b: star[21]
                    }));
                } else if (stars.length > 0 && !Array.isArray(stars[0])) {
                    loadingText.textContent = 'æ­£åœ¨è§„èŒƒå­—æ®µ...';
                    stars = normalizeStarsObjectArray(stars);
                }
                
                if (stars.length === 0) {
                    throw new Error('æ•°æ®æ–‡ä»¶ä¸ºç©º');
                }
                
                starData = stars;
                window.starData = starData;
                
                // æ£€æŸ¥æ˜¯å¦æœ‰é¢„å¤„ç†å¥½çš„å…«å‰æ ‘æ•°æ®
                if (data.star_positions && data.octree) {
                    loadingText.textContent = `æ­£åœ¨åŠ è½½å…«å‰æ ‘æ•°æ®...`;
                    starPositions = data.star_positions;
                    octree = loadOctreeFromData(data.octree);
                    
                    // åŸºæœ¬æ ¡éªŒ
                    let needRebuild = false;
                    if (!Array.isArray(starPositions) || starPositions.length !== stars.length) {
                        needRebuild = true;
                    } else {
                        const sampleCount = Math.min(10, starPositions.length);
                        for (let i = 0; i < sampleCount; i++) {
                            const p = starPositions[i];
                            if (!p || !Number.isFinite(p.x) || !Number.isFinite(p.y) || !Number.isFinite(p.z)) {
                                needRebuild = true;
                                break;
                            }
                        }
                    }
                    
                    if (needRebuild) {
                        loadingText.textContent = `é¢„å¤„ç†æ•°æ®å¼‚å¸¸ï¼Œæ­£åœ¨æœ¬åœ°é‡å»ºå…«å‰æ ‘...`;
                        octree = buildOctree(stars, 3);
                    }
                    
                    loadingText.textContent = `æ­£åœ¨æ¸²æŸ“ ${stars.length.toLocaleString()} é¢—æ’æ˜Ÿ...`;
                    createStars(starData);
                    loading.style.display = 'none';
                    
                    document.getElementById('stats').style.display = 'block';
                    document.getElementById('camera-controls').style.display = 'none';
                    document.getElementById('star-list-panel').style.display = 'flex';
                    document.getElementById('nearest-star-info').style.display = 'block';
                } else {
                    loadingText.textContent = `æ­£åœ¨æ¸²æŸ“ ${stars.length.toLocaleString()} é¢—æ’æ˜Ÿ...`;
                    createStars(starData);
                    loading.style.display = 'none';
                    
                    document.getElementById('stats').style.display = 'block';
                    document.getElementById('camera-controls').style.display = 'none';
                    document.getElementById('star-list-panel').style.display = 'flex';
                    document.getElementById('nearest-star-info').style.display = 'none';
                }
                
            } catch (error) {
                console.error('è‡ªåŠ¨ä¸‹è½½å¤±è´¥:', error);
                // éšè—åŠ è½½ç•Œé¢
                loading.style.display = 'none';
                // æ˜¾ç¤ºä¸Šä¼ é¢æ¿
                uploadPanel.style.display = 'block';
                const uploadError = document.getElementById('upload-error');
                const fileName = document.getElementById('file-name');
                
                if (uploadError) {
                    let errorMessage = `è‡ªåŠ¨ä¸‹è½½å¤±è´¥: ${error.message}\n\n`;
                    errorMessage += `è¯·æ‰‹åŠ¨ä¸Šä¼ æ•°æ®æ–‡ä»¶ã€‚\n`;
                    errorMessage += `æ”¯æŒæ ¼å¼ï¼šJSONæ–‡ä»¶ï¼ˆåŒ…å«æ’æ˜Ÿæ•°æ®ï¼‰`;
                    uploadError.textContent = errorMessage;
                    uploadError.style.display = 'block';
                    uploadError.style.color = '#ff8f8f';
                    uploadError.style.whiteSpace = 'pre-line';
                }
                
                if (fileName) {
                    fileName.textContent = '';
                }
                
                // ç¡®ä¿ä¸Šä¼ é¢æ¿å¯è§
                uploadPanel.style.opacity = '1';
                uploadPanel.style.visibility = 'visible';
            }
        }
        
        async function saveVisitorIP() {
            try {
                const response = await fetch('/api/save-ip.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({})
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('IP saved:', data.ip);
                }
            } catch (error) {
            }
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                detectMemoryAndDownload();
                saveVisitorIP();
            });
        } else {
            detectMemoryAndDownload();
            saveVisitorIP();
        }
        
        initScene();
        setupControls();
        setupStarList();
        // å³ä¸‹è§’ä¸‰ä¸ªæŒ‰é’®ï¼šä»…æ˜¾ç¤ºä¸€ä¸ªé¢æ¿
        const statsPanel = document.getElementById('stats');
        const starListPanel = document.getElementById('star-list-panel');
        const autoTourPanel = document.getElementById('auto-tour-panel');
        const btnShowStats = document.getElementById('btn-show-stats');
        const btnShowList = document.getElementById('btn-show-list');
        const btnShowAutoTour = document.getElementById('btn-show-auto-tour');
        let currentPanel = null; // 'stats' | 'list' | 'auto-tour' | null
        function showPanel(which) {
            if (!statsPanel || !starListPanel || !autoTourPanel) return;
            // æ ¹æ®æŒ‰é’®å®šä½é¢æ¿ï¼Œä½¿é¢æ¿å³ä¸‹è§’å¯¹å‡†å¯¹åº”æŒ‰é’®çš„åœ†å¿ƒ
            function positionPanelToButton(panelEl, btnEl) {
                if (!panelEl || !btnEl) return;
                const btnRect = btnEl.getBoundingClientRect();
                const btnCenterX = btnRect.left + btnRect.width / 2;
                const btnCenterY = btnRect.top + btnRect.height / 2;
                const rightPx = Math.max(0, window.innerWidth - btnCenterX);
                const bottomPx = Math.max(0, window.innerHeight - btnCenterY);
                panelEl.style.right = `${rightPx}px`;
                panelEl.style.bottom = `${bottomPx}px`;
            }
            if (which === 'stats') {
                statsPanel.style.display = 'block';
                starListPanel.style.display = 'flex';
                autoTourPanel.style.display = 'block';
                // åŠ¨ç”»ï¼šä»…è®©ç›®æ ‡é¢æ¿å¯è§
                statsPanel.classList.add('visible');
                starListPanel.classList.remove('visible');
                autoTourPanel.classList.remove('visible');
                positionPanelToButton(statsPanel, btnShowStats);
                if (btnShowStats) btnShowStats.classList.add('active');
                if (btnShowList) btnShowList.classList.remove('active');
                if (btnShowAutoTour) btnShowAutoTour.classList.remove('active');
            } else if (which === 'list') {
                statsPanel.style.display = 'block';
                starListPanel.style.display = 'flex';
                autoTourPanel.style.display = 'block';
                // åŠ¨ç”»ï¼šä»…è®©ç›®æ ‡é¢æ¿å¯è§
                statsPanel.classList.remove('visible');
                starListPanel.classList.add('visible');
                autoTourPanel.classList.remove('visible');
                positionPanelToButton(starListPanel, btnShowList);
                if (btnShowStats) btnShowStats.classList.remove('active');
                if (btnShowList) btnShowList.classList.add('active');
                if (btnShowAutoTour) btnShowAutoTour.classList.remove('active');
            } else if (which === 'auto-tour') {
                statsPanel.style.display = 'block';
                starListPanel.style.display = 'flex';
                autoTourPanel.style.display = 'block';
                // åŠ¨ç”»ï¼šä»…è®©ç›®æ ‡é¢æ¿å¯è§
                statsPanel.classList.remove('visible');
                starListPanel.classList.remove('visible');
                autoTourPanel.classList.add('visible');
                positionPanelToButton(autoTourPanel, btnShowAutoTour);
                if (btnShowStats) btnShowStats.classList.remove('active');
                if (btnShowList) btnShowList.classList.remove('active');
                if (btnShowAutoTour) btnShowAutoTour.classList.add('active');
            }
        }
        function hideAllPanels() {
            if (statsPanel) {
                statsPanel.classList.remove('visible');
                if (btnShowStats) btnShowStats.classList.remove('active');
            }
            if (starListPanel) {
                starListPanel.classList.remove('visible');
                if (btnShowList) btnShowList.classList.remove('active');
            }
            if (autoTourPanel) {
                autoTourPanel.classList.remove('visible');
                if (btnShowAutoTour) btnShowAutoTour.classList.remove('active');
            }
            currentPanel = null;
        }
        // å¹³æ»‘ç§»åŠ¨é¢æ¿åˆ°ç›®æ ‡ä½ç½®
        function animatePanelsToTarget() {
            if (panelAnimationTargets.size === 0) {
                if (panelAnimationId) {
                    cancelAnimationFrame(panelAnimationId);
                    panelAnimationId = null;
                }
                return;
            }
            
            const ANIMATION_SPEED = 0.1; // åŠ¨ç”»é€Ÿåº¦ï¼ˆ0-1ä¹‹é—´ï¼Œå€¼è¶Šå¤§è¶Šå¿«ï¼‰
            let hasActiveAnimations = false;
            
            panelAnimationTargets.forEach((target, panel) => {
                if (!panel) return;
                
                // è·å–å½“å‰å®é™…ä½ç½®ï¼ˆä» getBoundingClientRect è·å–ï¼Œæ›´å‡†ç¡®ï¼‰
                const rect = panel.getBoundingClientRect();
                const currentRight = window.innerWidth - rect.right;
                const currentBottom = window.innerHeight - rect.bottom;
                
                // è®¡ç®—å·®å€¼
                const diffRight = target.targetRight - currentRight;
                const diffBottom = target.targetBottom - currentBottom;
                
                // å¦‚æœè·ç¦»å¾ˆå°ï¼Œç›´æ¥è®¾ç½®ç›®æ ‡å€¼
                if (Math.abs(diffRight) < 0.5 && Math.abs(diffBottom) < 0.5) {
                    panel.style.right = `${target.targetRight}px`;
                    panel.style.bottom = `${target.targetBottom}px`;
                    panel.style.left = 'auto';
                    panel.style.top = 'auto';
                    panelAnimationTargets.delete(panel);
                    return;
                }
                
                // å¹³æ»‘ç§»åŠ¨
                const newRight = currentRight + diffRight * ANIMATION_SPEED;
                const newBottom = currentBottom + diffBottom * ANIMATION_SPEED;
                
                panel.style.right = `${newRight}px`;
                panel.style.bottom = `${newBottom}px`;
                panel.style.left = 'auto';
                panel.style.top = 'auto';
                
                hasActiveAnimations = true;
            });
            
            if (hasActiveAnimations) {
                panelAnimationId = requestAnimationFrame(animatePanelsToTarget);
            } else {
                panelAnimationId = null;
            }
        }
        
        // å°†é¢æ¿å¹³æ»‘ç§»åŠ¨åˆ°å·¦ä¸‹è§’
        function movePanelsToEarthIcon() {
            // å°†å¯è§çš„é¢æ¿å¹³æ»‘ç§»åŠ¨åˆ°å·¦ä¸‹è§’
            const panelsToMove = [];
            if (statsPanel && statsPanel.classList.contains('visible')) {
                panelsToMove.push(statsPanel);
            }
            if (starListPanel && starListPanel.classList.contains('visible')) {
                panelsToMove.push(starListPanel);
            }
            if (autoTourPanel && autoTourPanel.classList.contains('visible')) {
                panelsToMove.push(autoTourPanel);
            }
            
            panelsToMove.forEach(panel => {
                // è·å–é¢æ¿å®é™…å°ºå¯¸
                const rect = panel.getBoundingClientRect();
                const panelWidth = rect.width || 350;
                
                // å·¦ä¸‹è§’ä½ç½®ï¼šleft = 0, bottom = 0
                // è½¬æ¢ä¸º right/bottomï¼šright = window.innerWidth - panelWidth, bottom = 0
                const targetRight = window.innerWidth - panelWidth;
                const targetBottom = 0;
                
                // å­˜å‚¨åŠ¨ç”»ç›®æ ‡
                panelAnimationTargets.set(panel, {
                    targetRight: targetRight,
                    targetBottom: targetBottom
                });
            });
            
            // å¯åŠ¨åŠ¨ç”»
            if (panelsToMove.length > 0 && !panelAnimationId) {
                panelAnimationId = requestAnimationFrame(animatePanelsToTarget);
            }
        }
        // å°†é¢æ¿æ¢å¤åˆ°å¯¹åº”çš„å°æŒ‰é’®æ—è¾¹ï¼ˆä½¿ç”¨å¹³æ»‘åŠ¨ç”»ï¼‰
        function restorePanelsToButtons() {
            if (!statsPanel || !starListPanel || !autoTourPanel) return;
            
            // æ ¹æ®å½“å‰æ˜¾ç¤ºçš„é¢æ¿ï¼Œæ¢å¤åˆ°å¯¹åº”çš„å°æŒ‰é’®æ—è¾¹
            function positionPanelToButton(panelEl, btnEl) {
                if (!panelEl || !btnEl) return;
                const btnRect = btnEl.getBoundingClientRect();
                const btnCenterX = btnRect.left + btnRect.width / 2;
                const btnCenterY = btnRect.top + btnRect.height / 2;
                const rightPx = Math.max(0, window.innerWidth - btnCenterX);
                const bottomPx = Math.max(0, window.innerHeight - btnCenterY);
                
                // ä½¿ç”¨å¹³æ»‘åŠ¨ç”»ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
                panelAnimationTargets.set(panelEl, {
                    targetRight: rightPx,
                    targetBottom: bottomPx
                });
            }
            
            if (statsPanel.classList.contains('visible') && btnShowStats) {
                positionPanelToButton(statsPanel, btnShowStats);
            }
            if (starListPanel.classList.contains('visible') && btnShowList) {
                positionPanelToButton(starListPanel, btnShowList);
            }
            if (autoTourPanel.classList.contains('visible') && btnShowAutoTour) {
                positionPanelToButton(autoTourPanel, btnShowAutoTour);
            }
            
            // å¯åŠ¨åŠ¨ç”»
            if (panelAnimationTargets.size > 0 && !panelAnimationId) {
                panelAnimationId = requestAnimationFrame(animatePanelsToTarget);
            }
        }
        if (btnShowStats) btnShowStats.addEventListener('click', () => {
            if (currentPanel === 'stats') {
                hideAllPanels();
            } else {
                showPanel('stats');
                currentPanel = 'stats';
            }
        });
        if (btnShowList) btnShowList.addEventListener('click', () => {
            if (currentPanel === 'list') {
                hideAllPanels();
            } else {
                showPanel('list');
                currentPanel = 'list';
            }
        });
        if (btnShowAutoTour) btnShowAutoTour.addEventListener('click', () => {
            if (currentPanel === 'auto-tour') {
                hideAllPanels();
            } else {
                showPanel('auto-tour');
                currentPanel = 'auto-tour';
            }
        });
        // é»˜è®¤æ˜¾ç¤ºç»Ÿè®¡é¢æ¿ï¼Œç­‰æ•°æ®å°±ç»ªç”±æµå¼åŠ è½½åˆ‡æ¢åˆ°åˆ—è¡¨
        showPanel('stats');
        currentPanel = 'stats';
        // æš´éœ²ä»¥ä¾¿æµå¼åŠ è½½è°ƒç”¨
        window.__showPanel = showPanel;
        // çª—å£å°ºå¯¸å˜åŒ–æ—¶ï¼Œä¿æŒé¢æ¿å¯¹å‡†å¯¹åº”æŒ‰é’®
        window.addEventListener('resize', () => {
            if (statsPanel.classList.contains('visible')) {
                const btn = document.getElementById('btn-show-stats');
                if (btn) {
                    const rect = btn.getBoundingClientRect();
                    const rightPx = Math.max(0, window.innerWidth - (rect.left + rect.width / 2));
                    const bottomPx = Math.max(0, window.innerHeight - (rect.top + rect.height / 2));
                    statsPanel.style.right = `${rightPx}px`;
                    statsPanel.style.bottom = `${bottomPx}px`;
                }
            } else if (starListPanel.classList.contains('visible')) {
                const btn = document.getElementById('btn-show-list');
                if (btn) {
                    const rect = btn.getBoundingClientRect();
                    const rightPx = Math.max(0, window.innerWidth - (rect.left + rect.width / 2));
                    const bottomPx = Math.max(0, window.innerHeight - (rect.top + rect.height / 2));
                    starListPanel.style.right = `${rightPx}px`;
                    starListPanel.style.bottom = `${bottomPx}px`;
                }
            } else if (autoTourPanel && autoTourPanel.classList.contains('visible')) {
                const btn = document.getElementById('btn-show-auto-tour');
                if (btn) {
                    const rect = btn.getBoundingClientRect();
                    const rightPx = Math.max(0, window.innerWidth - (rect.left + rect.width / 2));
                    const bottomPx = Math.max(0, window.innerHeight - (rect.top + rect.height / 2));
                    autoTourPanel.style.right = `${rightPx}px`;
                    autoTourPanel.style.bottom = `${bottomPx}px`;
                }
            }
        });
        
        // è‡ªåŠ¨æ¼«æ¸¸åŠŸèƒ½
        function moveToNextStarInAutoTour() {
            if (!starData || starData.length === 0) return;
            
            let nextIndex;
            if (autoTourMode === 'random') {
                // éšæœºé€‰æ‹©
                nextIndex = Math.floor(Math.random() * starData.length);
            } else if (autoTourMode === 'backward') {
                // å€’åº
                nextIndex = (autoTourCurrentIndex - 1 + starData.length) % starData.length;
            } else {
                // é¡ºåºï¼ˆforwardï¼‰
                nextIndex = (autoTourCurrentIndex + 1) % starData.length;
            }
            
            autoTourCurrentIndex = nextIndex;
            autoTourLastIndex = nextIndex;
            autoTourStartTime = null;
            
            // å¯¼èˆªåˆ°ä¸‹ä¸€ä¸ªæ’æ˜Ÿ
            focusOnStar(nextIndex);
            updateAutoTourDisplay();
        }
        
        function updateAutoTourDisplay() {
            const currentEl = document.getElementById('auto-tour-current');
            const totalEl = document.getElementById('auto-tour-total');
            const modeEl = document.getElementById('auto-tour-mode');
            
            if (currentEl) currentEl.textContent = autoTourCurrentIndex + 1;
            if (totalEl) totalEl.textContent = starData.length;
            
            let modeText = '';
            if (autoTourMode === 'forward') modeText = 'é¡ºåºæ¼«æ¸¸';
            else if (autoTourMode === 'backward') modeText = 'å€’åºæ¼«æ¸¸';
            else if (autoTourMode === 'random') modeText = 'éšæœºé€‰æ‹©';
            if (modeEl) modeEl.textContent = modeText;
        }
        
        // è‡ªåŠ¨æ¼«æ¸¸æŒ‰é’®äº‹ä»¶
        const btnAutoTourStart = document.getElementById('btn-auto-tour-start');
        const btnAutoTourPause = document.getElementById('btn-auto-tour-pause');
        const btnAutoTourContinue = document.getElementById('btn-auto-tour-continue');
        const btnAutoTourRestart = document.getElementById('btn-auto-tour-restart');
        const btnAutoTourRandom = document.getElementById('btn-auto-tour-random');
        const btnAutoTourJumpLast = document.getElementById('btn-auto-tour-jump-last');
        const btnAutoTourForward = document.getElementById('btn-auto-tour-forward');
        const btnAutoTourBackward = document.getElementById('btn-auto-tour-backward');
        
        if (btnAutoTourStart) {
            btnAutoTourStart.addEventListener('click', () => {
                if (!starData || starData.length === 0) {
                    alert('è¯·å…ˆåŠ è½½æ’æ˜Ÿæ•°æ®');
                    return;
                }
                autoTourActive = true;
                autoTourPaused = false;
                if (autoTourCurrentIndex < 0 || autoTourCurrentIndex >= starData.length) {
                    autoTourCurrentIndex = 0;
                }
                focusOnStar(autoTourCurrentIndex);
                updateAutoTourDisplay();
            });
        }
        
        if (btnAutoTourPause) {
            btnAutoTourPause.addEventListener('click', () => {
                autoTourPaused = !autoTourPaused;
                if (autoTourPaused) {
                    btnAutoTourPause.textContent = 'ç»§ç»­';
                } else {
                    btnAutoTourPause.textContent = 'æš‚åœ';
                }
            });
        }
        
        if (btnAutoTourContinue) {
            btnAutoTourContinue.addEventListener('click', () => {
                if (autoTourLastIndex >= 0 && autoTourLastIndex < starData.length) {
                    autoTourActive = true;
                    autoTourPaused = false;
                    autoTourCurrentIndex = autoTourLastIndex;
                    focusOnStar(autoTourCurrentIndex);
                    updateAutoTourDisplay();
                } else {
                    alert('æ²¡æœ‰ä¸Šæ¬¡çš„æ¼«æ¸¸è®°å½•');
                }
            });
        }
        
        if (btnAutoTourRestart) {
            btnAutoTourRestart.addEventListener('click', () => {
                if (!starData || starData.length === 0) {
                    alert('è¯·å…ˆåŠ è½½æ’æ˜Ÿæ•°æ®');
                    return;
                }
                autoTourActive = true;
                autoTourPaused = false;
                autoTourCurrentIndex = 0;
                focusOnStar(0);
                updateAutoTourDisplay();
            });
        }
        
        if (btnAutoTourRandom) {
            btnAutoTourRandom.addEventListener('click', () => {
                if (!starData || starData.length === 0) {
                    alert('è¯·å…ˆåŠ è½½æ’æ˜Ÿæ•°æ®');
                    return;
                }
                autoTourActive = true;
                autoTourPaused = false;
                autoTourMode = 'random';
                autoTourCurrentIndex = Math.floor(Math.random() * starData.length);
                focusOnStar(autoTourCurrentIndex);
                updateAutoTourDisplay();
            });
        }
        
        if (btnAutoTourJumpLast) {
            btnAutoTourJumpLast.addEventListener('click', () => {
                if (autoTourLastIndex >= 0 && autoTourLastIndex < starData.length) {
                    focusOnStar(autoTourLastIndex);
                    autoTourCurrentIndex = autoTourLastIndex;
                    updateAutoTourDisplay();
                } else {
                    alert('æ²¡æœ‰ä¸Šæ¬¡çš„æ¼«æ¸¸è®°å½•');
                }
            });
        }
        
        if (btnAutoTourForward) {
            btnAutoTourForward.addEventListener('click', () => {
                autoTourMode = 'forward';
                updateAutoTourDisplay();
            });
        }
        
        if (btnAutoTourBackward) {
            btnAutoTourBackward.addEventListener('click', () => {
                autoTourMode = 'backward';
                updateAutoTourDisplay();
            });
        }
        
        // åˆå§‹åŒ–æ˜¾ç¤º
        updateAutoTourDisplay();
        
        // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€ä¸ºéšè—
        function initButtonStates() {
            const cornerButtons = document.getElementById('corner-buttons');
            if (cornerButtons) {
                const buttons = cornerButtons.querySelectorAll('.corner-switch');
                buttons.forEach(btn => {
                    // ä»CSSä¸­è·å–åŸæœ‰çš„translateå€¼
                    let translateX = 0, translateY = 0;
                    if (btn.id === 'btn-show-stats') {
                        translateX = 0;
                        translateY = -88;
                    } else if (btn.id === 'btn-show-auto-tour') {
                        translateX = -62;
                        translateY = -62;
                    } else if (btn.id === 'btn-show-list') {
                        translateX = -88;
                        translateY = 0;
                    }
                    
                    // åˆå§‹çŠ¶æ€ï¼šå®Œå…¨éšè—ï¼Œä»ä¸­å¿ƒ(0,0)å¼€å§‹
                    btn.style.opacity = '0';
                    btn.style.transform = `translate(0px, 0px) scale(0)`;
                    btn.style.pointerEvents = 'none';
                    btn.style.visibility = 'hidden';
                    btn.style.transition = 'none';
                    
                    // æ·»åŠ é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨ï¼Œç”¨äºæ£€æµ‹æ‚¬åœåœ¨å°æŒ‰é’®ä¸Š
                    btn.addEventListener('mouseenter', () => {
                        isHoveringSmallButtons = true;
                        // å–æ¶ˆå»¶è¿Ÿæ”¶å›å®šæ—¶å™¨å’Œæ ‡å¿—
                        if (buttonHideTimer) {
                            clearTimeout(buttonHideTimer);
                            buttonHideTimer = null;
                        }
                        shouldHideButtonsAfterDelay = false;
                    });
                    btn.addEventListener('mouseleave', () => {
                        isHoveringSmallButtons = false;
                        // å¦‚æœè·ç¦»æ¥è¿‘ï¼Œé‡æ–°å¯åŠ¨å»¶è¿Ÿæ”¶å›å®šæ—¶å™¨
                        if (camera && earthGlobeIcon) {
                            const buttonCenterX = window.innerWidth - 20 + 60;
                            const buttonCenterY = window.innerHeight - 20 + 60;
                            const ndcX = (buttonCenterX / window.innerWidth) * 2 - 1;
                            const ndcY = -(buttonCenterY / window.innerHeight) * 2 + 1;
                            const vector = new THREE.Vector3(ndcX, ndcY, 0.5);
                            vector.unproject(camera);
                            const dir = vector.sub(camera.position).normalize();
                            const button3DPos = camera.position.clone().add(dir.multiplyScalar(100));
                            const distance = camera.position.distanceTo(button3DPos);
                            
                            if (distance < BUTTON_SHOW_DISTANCE && !window.isHoveringEarthIcon) {
                                // é‡ç½®æ ‡å¿—
                                shouldHideButtonsAfterDelay = false;
                                // é‡æ–°å¯åŠ¨å»¶è¿Ÿæ”¶å›å®šæ—¶å™¨
                                if (!buttonHideTimer) {
                                    buttonHideTimer = setTimeout(() => {
                                        // å»¶è¿Ÿåï¼Œå¦‚æœä»ç„¶åº”è¯¥éšè—ä¸”æ²¡æœ‰æ‚¬åœåœ¨å°æŒ‰é’®ä¸Šï¼Œåˆ™è®¾ç½®æ ‡å¿—è§¦å‘åŠ¨ç”»
                                        if (!isHoveringSmallButtons && !window.isHoveringEarthIcon) {
                                            shouldHideButtonsAfterDelay = true;
                                        }
                                        buttonHideTimer = null;
                                    }, BUTTON_HIDE_DELAY);
                                }
                            }
                        }
                    });
                });
            }
        }
        initButtonStates();
        
        // æ’æ˜Ÿåˆ—è¡¨ä¸­çš„è·³è½¬æŒ‰é’®
        const btnJumpToLastAutoTour = document.getElementById('btn-jump-to-last-auto-tour');
        if (btnJumpToLastAutoTour) {
            btnJumpToLastAutoTour.addEventListener('click', () => {
                if (autoTourLastIndex >= 0 && autoTourLastIndex < starData.length) {
                    focusOnStar(autoTourLastIndex);
                    autoTourCurrentIndex = autoTourLastIndex;
                    updateAutoTourDisplay();
                } else {
                    alert('æ²¡æœ‰ä¸Šæ¬¡çš„è‡ªåŠ¨æ¼«æ¸¸è®°å½•');
                }
            });
        }

        // â€”â€” æ’æ˜Ÿåˆ—è¡¨æµå¼åŠ è½½ï¼ˆå¢é‡æ¸²æŸ“ï¼‰ â€”â€”
        (function setupStreamingStarList() {
            const container = document.getElementById('star-list-container');
            const listEl = document.getElementById('star-list');
            const searchEl = document.getElementById('star-search');
            const countEl = document.getElementById('star-list-count');
            if (!container || !listEl) return;
            const BATCH_SIZE = 50; // æ¯æ¬¡åŠ è½½50æ¡
            let filteredIndices = [];
            let renderedCount = 0;
            let initDone = false;
            let rendering = false;

            function computeFiltered() {
                const term = (searchEl && searchEl.value ? searchEl.value : '').trim().toLowerCase();
                if (!Array.isArray(window.starData) || window.starData.length === 0) {
                    filteredIndices = [];
                    renderedCount = 0;
                    listEl.innerHTML = '';
                    if (countEl) countEl.textContent = 'å…± 0 é¢—æ’æ˜Ÿ';
                    return;
                }
                if (!term) {
                    filteredIndices = window.starData.map((_, i) => i);
                } else {
                    filteredIndices = [];
                    for (let i = 0; i < window.starData.length; i++) {
                        const star = window.starData[i];
                        const id = star && star.source_id ? String(star.source_id).toLowerCase() : '';
                        if (id.includes(term)) filteredIndices.push(i);
                    }
                }
                // é‡ç½®åˆ—è¡¨ä¸è®¡æ•°
                renderedCount = 0;
                listEl.innerHTML = '';
                if (countEl) {
                    const total = window.starData.length;
                    const filtered = filteredIndices.length;
                    countEl.textContent = term ? `æ˜¾ç¤º ${filtered.toLocaleString()} / å…± ${total.toLocaleString()} é¢—æ’æ˜Ÿ` : `å…± ${total.toLocaleString()} é¢—æ’æ˜Ÿ`;
                }
            }

            function appendBatch(n = BATCH_SIZE) {
                if (rendering) return;
                if (renderedCount >= filteredIndices.length) return;
                rendering = true;
                const end = Math.min(renderedCount + n, filteredIndices.length);
                const frag = document.createDocumentFragment();
                for (let k = renderedCount; k < end; k++) {
                    const originalIndex = filteredIndices[k];
                    const star = window.starData[originalIndex];
                    const li = document.createElement('li');
                    const starId = (star && star.source_id) ? String(star.source_id) : `æœªçŸ¥-${originalIndex}`;
                    li.textContent = starId;
                    li.dataset.originalIndex = String(originalIndex);
                    li.style.cursor = 'pointer';
                    li.addEventListener('click', () => {
                        if (typeof window.focusOnStar === 'function') window.focusOnStar(originalIndex);
                    });
                    frag.appendChild(li);
                }
                listEl.appendChild(frag);
                renderedCount = end;
                rendering = false;
            }

            let scrollThrottle = false;
            function onScrollLoadMore() {
                if (scrollThrottle) return;
                if (renderedCount >= filteredIndices.length) return; // å·²åŠ è½½å®Œ
                const nearBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 40;
                if (nearBottom) {
                    scrollThrottle = true;
                    appendBatch(BATCH_SIZE);
                    // é˜²æŠ–ï¼š200msåæ‰èƒ½å†æ¬¡è§¦å‘
                    setTimeout(() => { scrollThrottle = false; }, 200);
                }
            }

            function init() {
                if (initDone) return;
                if (!Array.isArray(window.starData) || window.starData.length === 0) return;
                initDone = true;
                computeFiltered();
                // å…ˆåŠ è½½å‰50æ¡å¹¶å±•å¼€â€œåˆ—è¡¨â€é¢æ¿
                appendBatch(BATCH_SIZE);
                if (typeof window.__showPanel === 'function') window.__showPanel('list');
                // åªåœ¨æ»šåŠ¨åˆ°åº•éƒ¨æ—¶åŠ è½½æ›´å¤š
                container.removeEventListener('scroll', onScrollLoadMore);
                container.addEventListener('scroll', onScrollLoadMore);
                if (searchEl) {
                    searchEl.removeEventListener('input', handleSearch);
                    searchEl.addEventListener('input', handleSearch);
                }
            }

            function handleSearch() {
                computeFiltered();
                // å…ˆåŠ è½½å‰50æ¡
                appendBatch(BATCH_SIZE);
                // åç»­åªåœ¨æ»šåŠ¨åˆ°åº•éƒ¨æ—¶åŠ è½½æ›´å¤šï¼ˆé€šè¿‡onScrollLoadMoreï¼‰
            }

            // è½®è¯¢ç­‰å¾… starData å°±ç»ªï¼ˆæ–‡ä»¶ä¸Šä¼ å®Œæ¯•åï¼‰
            const waitTimer = setInterval(() => {
                if (Array.isArray(window.starData) && window.starData.length > 0) {
                    clearInterval(waitTimer);
                    init();
                }
            }, 300);
            // è‹¥å·²æœ‰æ•°æ®åˆ™ç«‹å³åˆå§‹åŒ–
            if (Array.isArray(window.starData) && window.starData.length > 0) {
                clearInterval(waitTimer);
                init();
            }
        })();
        // é€Ÿåº¦é¢„è®¾æŒ‰é’®
        const btnHigh = document.getElementById('speed-high');
        const btnMed = document.getElementById('speed-medium');
        const btnLow = document.getElementById('speed-low');
        function applySpeedPreset(base, m1, m2, m3) {
            if (controls) {
                controls.moveSpeed = HighPrecisionMath.toInt(base);
                controls.speedMultiplier1 = m1;
                controls.speedMultiplier2 = m2;
                controls.speedMultiplier3 = m3;
            }
            // æ›´æ–°æ˜¾ç¤ºæ–‡æœ¬ï¼ˆå³ä½¿æ§ä»¶éšè—ï¼Œä¹Ÿä¿æŒä¸€è‡´ï¼‰
            const sp = document.getElementById('camera-speed-value');
            if (sp) sp.textContent = base;
            const m1v = document.getElementById('speed-multiplier1-value');
            const m1p = document.getElementById('speed-multiplier1-percent');
            if (m1v) m1v.textContent = m1.toFixed(2);
            if (m1p) m1p.textContent = (m1 * 100).toFixed(0);
            const m2v = document.getElementById('speed-multiplier2-value');
            const m2p = document.getElementById('speed-multiplier2-percent');
            if (m2v) m2v.textContent = m2.toFixed(2);
            if (m2p) m2p.textContent = (m2 * 100).toFixed(0);
            const m3v = document.getElementById('speed-multiplier3-value');
            const m3p = document.getElementById('speed-multiplier3-percent');
            if (m3v) m3v.textContent = m3.toFixed(2);
            if (m3p) m3p.textContent = (m3 * 100).toFixed(0);
        }
        // é«˜é€Ÿä¸å˜ï¼šä¿æŒ (25, 0.4, 1.0, 1.0)
        if (btnHigh) btnHigh.addEventListener('click', () => applySpeedPreset(25, 0.4, 1.0, 1.0));
        // ä¸­é€Ÿæ”¹ä¸ºç°åœ¨çš„ä½é€Ÿï¼š(25, 0.4 / 16, 1.0, 1.0)
        if (btnMed) btnMed.addEventListener('click', () => applySpeedPreset(25, 0.4 / 16, 1.0, 1.0));
        // ä½é€Ÿæ”¹ä¸º100åˆ†ä¹‹1é«˜é€Ÿï¼š(25, 0.4 / 100, 1.0, 1.0)
        if (btnLow) btnLow.addEventListener('click', () => applySpeedPreset(25, 0.4 / 100, 1.0, 1.0));
        animate();
        
        const fileInput = document.getElementById('file-input');
        if (fileInput) {
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleFileUpload(file);
                }
            });
        }
        
        const btnHelp = document.getElementById('btn-help');
        const btnCloseHelp = document.getElementById('btn-close-help');
        const helpBackdrop = document.getElementById('help-backdrop');
        const btnPrecision = document.getElementById('btn-toggle-precision');
        
        function setHelpVisible(visible) {
            if (!helpBackdrop) return;
            helpBackdrop.style.display = visible ? 'flex' : 'none';
        }
        function resetCameraView() {
            if (!controls || !camera) return;
            controls.setPosition(0, 0, 500);
            controls.setRotation(0, 0);
        }
        function syncPrecisionToggleUI() {
            if (!btnPrecision) return;
            const enabled = !!(controls && controls.highPrecisionMode);
            btnPrecision.textContent = `é«˜ç²¾åº¦: ${enabled ? 'å¼€' : 'å…³'}`;
        }
        if (btnHelp) btnHelp.addEventListener('click', () => setHelpVisible(true));
        if (btnCloseHelp) btnCloseHelp.addEventListener('click', () => setHelpVisible(false));
        if (helpBackdrop) helpBackdrop.addEventListener('click', (e) => {
            if (e.target === helpBackdrop) setHelpVisible(false);
        });
        if (btnPrecision) btnPrecision.addEventListener('click', () => {
            if (!controls) return;
            controls.setHighPrecisionMode(!controls.highPrecisionMode);
            const highPrecisionToggle = document.getElementById('high-precision-toggle');
            if (highPrecisionToggle) highPrecisionToggle.checked = controls.highPrecisionMode;
            syncPrecisionToggleUI();
        });
        syncPrecisionToggleUI();
        
        const uploadPanelEl = document.getElementById('upload-panel');
        if (uploadPanelEl) {
            const prevent = (e) => { e.preventDefault(); e.stopPropagation(); };
            ['dragenter','dragover','dragleave','drop'].forEach(evt => {
                uploadPanelEl.addEventListener(evt, prevent);
            });
            uploadPanelEl.addEventListener('dragover', () => {
                uploadPanelEl.classList.add('dragover');
            });
            uploadPanelEl.addEventListener('dragleave', () => {
                uploadPanelEl.classList.remove('dragover');
            });
            uploadPanelEl.addEventListener('drop', (e) => {
                uploadPanelEl.classList.remove('dragover');
                const dt = e.dataTransfer;
                if (dt && dt.files && dt.files.length > 0) {
                    const file = dt.files[0];
                    if (file) handleFileUpload(file);
                }
            });
        }
    </script>
</body>
</html>

